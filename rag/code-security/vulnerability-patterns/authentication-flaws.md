<!--
Copyright (c) 2025 Crash Override Inc. - https://crashoverride.com

SPDX-License-Identifier: GPL-3.0
-->

# Authentication & Authorization Vulnerability Patterns

## Hardcoded Credentials (CWE-798)

### Description
Hardcoded credentials in source code can be extracted by attackers who gain access to the codebase.

### Dangerous Patterns

**Hardcoded Passwords**
```python
# VULNERABLE
DB_PASSWORD = "secret123"
API_KEY = "sk-1234567890abcdef"

def connect():
    return mysql.connect(password="admin123")
```

```javascript
// VULNERABLE
const config = {
  password: 'mysecretpassword',
  apiKey: 'sk_live_xxxxxxxxxxxx'
};
```

```java
// VULNERABLE
private static final String DB_PASSWORD = "password123";
private static final String API_KEY = "AKIAIOSFODNN7EXAMPLE";
```

**Hardcoded Tokens**
```python
# VULNERABLE
GITHUB_TOKEN = "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
SLACK_TOKEN = "xoxb-xxxxxxxxxxxx-xxxxxxxxxxxx-xxxxxxxxxxxxxxxxxxxxxxxx"
```

### Safe Patterns

**Environment Variables**
```python
# SECURE
import os
DB_PASSWORD = os.environ.get("DB_PASSWORD")
if not DB_PASSWORD:
    raise ValueError("DB_PASSWORD not set")
```

```javascript
// SECURE
const config = {
  password: process.env.DB_PASSWORD,
  apiKey: process.env.API_KEY
};
```

**Secrets Manager**
```python
# SECURE
import boto3
client = boto3.client('secretsmanager')
secret = client.get_secret_value(SecretId='prod/db/password')
```

### Detection Indicators
- Variables named: password, secret, key, token, credential, auth
- Strings matching API key patterns (see secrets-detection prompt)
- Base64 encoded strings assigned to sensitive variables
- Connection strings with embedded credentials

---

## Broken Authentication (CWE-306)

### Description
Missing or inadequate authentication allows unauthorized access to protected resources.

### Dangerous Patterns

**Missing Authentication**
```python
# VULNERABLE - no authentication check
@app.route('/admin/users')
def list_users():
    return jsonify(User.query.all())
```

```javascript
// VULNERABLE - endpoint without auth middleware
app.get('/api/admin/data', (req, res) => {
  res.json(sensitiveData);
});
```

**Weak Password Validation**
```python
# VULNERABLE - no password requirements
def register(username, password):
    if len(password) > 0:  # Too weak
        create_user(username, password)
```

### Safe Patterns

**Proper Authentication**
```python
# SECURE
@app.route('/admin/users')
@login_required
@admin_required
def list_users():
    return jsonify(User.query.all())
```

```javascript
// SECURE
app.get('/api/admin/data', authenticateToken, requireAdmin, (req, res) => {
  res.json(sensitiveData);
});
```

**Strong Password Policy**
```python
# SECURE
import re
def validate_password(password):
    if len(password) < 12:
        raise ValueError("Password must be at least 12 characters")
    if not re.search(r'[A-Z]', password):
        raise ValueError("Password must contain uppercase")
    if not re.search(r'[a-z]', password):
        raise ValueError("Password must contain lowercase")
    if not re.search(r'\d', password):
        raise ValueError("Password must contain digit")
    if not re.search(r'[!@#$%^&*]', password):
        raise ValueError("Password must contain special character")
```

---

## Broken Access Control (CWE-284)

### Description
Improper access control allows users to access resources or perform actions they shouldn't be authorized for.

### Dangerous Patterns

**Insecure Direct Object Reference (IDOR)**
```python
# VULNERABLE - no ownership check
@app.route('/api/documents/<doc_id>')
def get_document(doc_id):
    return Document.query.get(doc_id)
```

```javascript
// VULNERABLE - user can access any account
app.get('/api/account/:id', (req, res) => {
  const account = await Account.findById(req.params.id);
  res.json(account);
});
```

**Missing Authorization Check**
```python
# VULNERABLE - authenticated but not authorized
@app.route('/api/users/<user_id>/delete', methods=['POST'])
@login_required
def delete_user(user_id):
    User.query.get(user_id).delete()  # No admin check
```

### Safe Patterns

**Proper Authorization**
```python
# SECURE - ownership verification
@app.route('/api/documents/<doc_id>')
@login_required
def get_document(doc_id):
    doc = Document.query.get(doc_id)
    if doc.owner_id != current_user.id:
        abort(403)
    return doc
```

```javascript
// SECURE - verify ownership
app.get('/api/account/:id', authenticateToken, async (req, res) => {
  if (req.params.id !== req.user.accountId && !req.user.isAdmin) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  const account = await Account.findById(req.params.id);
  res.json(account);
});
```

**Role-Based Access Control**
```python
# SECURE
@app.route('/api/users/<user_id>/delete', methods=['POST'])
@login_required
@admin_required  # Decorator checks role
def delete_user(user_id):
    User.query.get(user_id).delete()
```

---

## Session Management Issues (CWE-384)

### Dangerous Patterns

**Session Fixation**
```python
# VULNERABLE - not regenerating session after login
@app.route('/login', methods=['POST'])
def login():
    if check_credentials(request.form):
        session['user'] = request.form['username']
        # Session ID not regenerated!
```

**Insecure Session Storage**
```javascript
// VULNERABLE - storing session in localStorage
localStorage.setItem('authToken', token);
// Can be accessed by XSS
```

### Safe Patterns

**Session Regeneration**
```python
# SECURE
from flask import session
@app.route('/login', methods=['POST'])
def login():
    if check_credentials(request.form):
        session.clear()  # Clear old session
        session.regenerate()  # New session ID
        session['user'] = request.form['username']
```

**Secure Cookie Storage**
```javascript
// SECURE - use httpOnly cookies
res.cookie('authToken', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict'
});
```

---

## Privilege Escalation (CWE-269)

### Dangerous Patterns

```python
# VULNERABLE - role stored client-side
@app.route('/api/action')
def do_action():
    role = request.headers.get('X-User-Role')  # Trust client header!
    if role == 'admin':
        perform_admin_action()
```

### Safe Patterns

```python
# SECURE - role from server-side session
@app.route('/api/action')
@login_required
def do_action():
    user = User.query.get(current_user.id)
    if user.role == 'admin':  # From database
        perform_admin_action()
```
