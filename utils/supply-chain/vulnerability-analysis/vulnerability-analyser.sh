#!/bin/bash
# Copyright (c) 2025 Crash Override Inc.
# https://crashoverride.com
# 
# SPDX-License-Identifier: GPL-3.0

#############################################################################
# Vulnerability Analyser Script
# Analyzes SBOMs and repositories for vulnerabilities using osv-scanner
# Supports taint analysis for reachability determination
# Usage: ./vulnerability-analyser.sh [options] <target>
#############################################################################

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PARENT_DIR="$(dirname "$SCRIPT_DIR")"
CONFIG_FILE="$PARENT_DIR/config.json"

# Default options
TAINT_ANALYSIS=false
OUTPUT_FORMAT="markdown"
TEMP_DIR=""
LOCAL_PATH=""
CLEANUP=true
ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
# Claude enabled by default if API key is set
USE_CLAUDE=false
if [[ -n "$ANTHROPIC_API_KEY" ]]; then
    USE_CLAUDE=true
fi
PRIORITIZE=false
KEV_CACHE=""
MULTI_REPO_MODE=false
TARGETS_LIST=()
PARALLEL=true
SBOM_FILE=""  # For batch API mode

# Function to print usage
usage() {
    cat << EOF
Vulnerability Analyser - Vulnerability scanning with osv-scanner

Usage: $0 [OPTIONS] [target]

TARGET:
    SBOM file path          Analyze an existing SBOM (JSON/XML)
    Git repository URL      Clone and analyze repository
    Local directory path    Analyze local repository
    (If no target specified, uses config.json)

MULTI-REPO OPTIONS:
    --org ORG_NAME          Scan all repos in GitHub organization
    --repo OWNER/REPO       Scan specific repository
    --config FILE           Use alternate config file

ANALYSIS OPTIONS:
    -t, --taint-analysis    Enable call graph/taint analysis (Go projects)
    -p, --prioritize        Add intelligent prioritization (CISA KEV, CVSS, exploitability)
    --parallel              Batch API processing (default: enabled)
    --sbom FILE             Use existing SBOM file for batch API scanning
    --claude                Use Claude AI for enhanced analysis (requires ANTHROPIC_API_KEY)
    --local-path PATH       Use pre-cloned repository at PATH (skips cloning)
    -f, --format FORMAT     Output format: table|json|markdown|sarif (default: markdown)
    -o, --output FILE       Write results to file
    -k, --keep-clone        Keep cloned repository (don't cleanup)
    -h, --help              Show this help message

EXAMPLES:
    # Analyze an SBOM file
    $0 /path/to/sbom.json

    # Analyze with prioritization
    $0 --prioritize https://github.com/org/repo

    # Use batch API for faster scanning (recommended for large SBOMs)
    $0 --parallel --sbom /path/to/sbom.json

    # Scan entire GitHub organization
    $0 --prioritize --org myorg

    # Scan multiple repositories
    $0 --prioritize --repo owner/repo1 --repo owner/repo2

    # Use configured targets from config.json
    $0 --prioritize

EOF
    exit 1
}

# Function to check if osv-scanner is installed
check_osv_scanner() {
    if ! command -v osv-scanner &> /dev/null; then
        echo -e "${RED}Error: osv-scanner is not installed${NC}"
        echo ""
        echo "Install osv-scanner:"
        echo "  go install github.com/google/osv-scanner/cmd/osv-scanner@latest"
        echo ""
        echo "Or with Homebrew:"
        echo "  brew install osv-scanner"
        echo ""
        exit 1
    fi
}

# Function to check if jq is installed
check_jq() {
    if ! command -v jq &> /dev/null; then
        echo -e "${RED}Error: jq is not installed (required for prioritization)${NC}"
        echo ""
        echo "Install jq:"
        echo "  brew install jq  (macOS)"
        echo "  apt-get install jq  (Debian/Ubuntu)"
        echo ""
        exit 1
    fi
}

# Function to expand org into repos
expand_org_repos() {
    local org="$1"
    echo -e "${BLUE}Fetching repositories for org: $org${NC}" >&2

    if ! command -v gh &> /dev/null; then
        echo -e "${RED}Error: gh (GitHub CLI) is required for org scanning${NC}" >&2
        echo "Install: brew install gh" >&2
        return 1
    fi

    local repos=$(gh repo list "$org" --limit 1000 --json nameWithOwner --jq '.[].nameWithOwner' 2>/dev/null || echo "")

    if [[ -z "$repos" ]]; then
        echo -e "${YELLOW}âš  No repositories found for org: $org${NC}" >&2
        return 1
    fi

    echo "$repos"
}

# Function to load targets from config
load_config_targets() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        return 1
    fi

    local config_orgs=$(jq -r '.github.organizations[]?' "$CONFIG_FILE" 2>/dev/null || echo "")
    local config_repos=$(jq -r '.github.repositories[]?' "$CONFIG_FILE" 2>/dev/null || echo "")

    # Add orgs
    while IFS= read -r org; do
        [[ -n "$org" ]] && TARGETS_LIST+=("org:$org")
    done <<< "$config_orgs"

    # Add repos
    while IFS= read -r repo; do
        [[ -n "$repo" ]] && TARGETS_LIST+=("repo:$repo")
    done <<< "$config_repos"

    return 0
}

# Function to fetch CISA KEV catalog
fetch_kev_catalog() {
    KEV_CACHE=$(mktemp)
    echo -e "${BLUE}Fetching CISA KEV catalog...${NC}" >&2

    if curl -s "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json" -o "$KEV_CACHE"; then
        echo -e "${GREEN}âœ“ KEV catalog downloaded${NC}" >&2
        return 0
    else
        echo -e "${YELLOW}âš  Failed to fetch KEV catalog${NC}" >&2
        return 1
    fi
}

# Function to check if CVE is in CISA KEV
is_in_kev() {
    local cve_id="$1"
    if [[ -z "$KEV_CACHE" ]] || [[ ! -f "$KEV_CACHE" ]]; then
        return 1
    fi
    jq -e ".vulnerabilities[] | select(.cveID == \"$cve_id\")" "$KEV_CACHE" > /dev/null 2>&1
}

# Function to prioritize vulnerabilities
prioritize_results() {
    local scan_output="$1"
    local format="${2:-$OUTPUT_FORMAT}"
    local prioritized_output=$(mktemp)


    # Parse vulnerabilities and add priority scores
    # Note: osv-scanner structure is .results[].packages[].vulnerabilities[]
    jq -r '.results[]? | .packages[]? | select(.vulnerabilities) |
        .package as $pkg | .vulnerabilities[] |
        {
            id: (.id // "N/A"),
            package: ($pkg.name // "N/A"),
            version: ($pkg.version // "N/A"),
            ecosystem: ($pkg.ecosystem // "N/A"),
            cvss: ((.database_specific.cvss // .database_specific.severity // "0") | tostring),
            summary: (.summary // .details // "No description available")
        } | @json' "$scan_output" 2>/dev/null | while IFS= read -r vuln_json; do

        # Extract fields
        local vuln_id=$(echo "$vuln_json" | jq -r '.id')
        local package=$(echo "$vuln_json" | jq -r '.package')
        local version=$(echo "$vuln_json" | jq -r '.version')
        local cvss=$(echo "$vuln_json" | jq -r '.cvss' | grep -oE '[0-9]+(\.[0-9]+)?' | head -1 || echo "0")
        local summary=$(echo "$vuln_json" | jq -r '.summary' | head -c 100)

        # Calculate priority score
        local priority_score=0
        local priority_label="LOW"
        local flags=""

        # CISA KEV check (highest priority)
        if is_in_kev "$vuln_id"; then
            priority_score=$((priority_score + 100))
            flags="${flags}[KEV] "
        fi

        # CVSS score
        if [[ -n "$cvss" ]] && [[ "$cvss" != "0" ]]; then
            # CVSS to priority: 9-10=Critical(50), 7-8.9=High(30), 4-6.9=Medium(15), 0-3.9=Low(5)
            if (( $(echo "$cvss >= 9.0" | bc -l 2>/dev/null || echo 0) )); then
                priority_score=$((priority_score + 50))
            elif (( $(echo "$cvss >= 7.0" | bc -l 2>/dev/null || echo 0) )); then
                priority_score=$((priority_score + 30))
            elif (( $(echo "$cvss >= 4.0" | bc -l 2>/dev/null || echo 0) )); then
                priority_score=$((priority_score + 15))
            else
                priority_score=$((priority_score + 5))
            fi
        fi

        # Determine priority label
        if [[ $priority_score -ge 100 ]]; then
            priority_label="CRITICAL"
        elif [[ $priority_score -ge 50 ]]; then
            priority_label="HIGH"
        elif [[ $priority_score -ge 30 ]]; then
            priority_label="MEDIUM"
        fi

        # Store with priority
        echo "$priority_score|$priority_label|$flags|$vuln_id|$package|$version|$cvss|$summary" >> "$prioritized_output"
    done

    # Sort by priority score (descending) and display
    if [[ -f "$prioritized_output" ]] && [[ -s "$prioritized_output" ]]; then
        # Summary statistics (use subshell to avoid grep exit code issues)
        local total=$(wc -l < "$prioritized_output" | tr -d ' ')
        local critical; critical=$(grep -c "^[0-9]*|CRITICAL|" "$prioritized_output" 2>/dev/null) || critical=0
        local high; high=$(grep -c "^[0-9]*|HIGH|" "$prioritized_output" 2>/dev/null) || high=0
        local medium; medium=$(grep -c "^[0-9]*|MEDIUM|" "$prioritized_output" 2>/dev/null) || medium=0
        local low; low=$(grep -c "^[0-9]*|LOW|" "$prioritized_output" 2>/dev/null) || low=0
        local kev; kev=$(grep -c "\[KEV\]" "$prioritized_output" 2>/dev/null) || kev=0

        # Terminal output: summary only
        echo -e "${GREEN}Vulnerability Summary:${NC}"
        echo "  Total: $total (Critical: $critical, High: $high, Medium: $medium, Low: $low)"
        if [[ $kev -gt 0 ]]; then
            echo -e "  ${RED}CISA KEV: $kev${NC}"
        fi

        rm -f "$prioritized_output"
    else
        echo -e "${GREEN}No vulnerabilities found${NC}"
    fi
}

# Function to detect if target is a Git URL
is_git_url() {
    [[ "$1" =~ ^(https?|git)://.*\.git$ ]] || [[ "$1" =~ ^git@.*:.*\.git$ ]] || [[ "$1" =~ github\.com|gitlab\.com|bitbucket\.org ]]
}

# Function to detect if target is an SBOM file
is_sbom_file() {
    local file="$1"
    [[ -f "$file" ]] && ([[ "$file" =~ \.json$ ]] || [[ "$file" =~ \.xml$ ]] || [[ "$file" =~ \.cdx\. ]] || [[ "$file" =~ bom\. ]])
}

# Function to clone repository
clone_repository() {
    local repo_url="$1"
    TEMP_DIR=$(mktemp -d)

    echo -e "${BLUE}Cloning repository...${NC}"
    if git clone --depth 1 "$repo_url" "$TEMP_DIR"; then
        echo -e "${GREEN}âœ“ Repository cloned to: $TEMP_DIR${NC}"
        echo ""
        return 0
    else
        echo -e "${RED}âœ— Failed to clone repository${NC}"
        echo -e "${YELLOW}Note: For private repositories, ensure you have proper SSH keys or authentication${NC}"
        return 1
    fi
}

# Function to run osv-scanner on SBOM
# Load OSV batch client if available
OSV_CLIENT_LIB="$SCRIPT_DIR/lib/osv-client.sh"
if [[ -f "$OSV_CLIENT_LIB" ]]; then
    source "$OSV_CLIENT_LIB"
fi

# Function to scan SBOM using batch API
scan_sbom_batch() {
    local sbom_file="$1"
    local output_file="$2"

    # Check if OSV client is loaded
    if ! command -v osv_scan_sbom &> /dev/null; then
        PARALLEL=false
        scan_sbom "$sbom_file" "$output_file"
        return
    fi

    # Run batch scan
    local batch_results=$(osv_scan_sbom "$sbom_file")

    if echo "$batch_results" | jq -e '.error' > /dev/null 2>&1; then
        PARALLEL=false
        scan_sbom "$sbom_file" "$output_file"
        return
    fi

    # Extract stats
    local total_vulns=$(echo "$batch_results" | jq -r '.total_vulns // 0')
    local packages_scanned=$(echo "$batch_results" | jq -r '.packages_scanned // 0')
    local packages_with_vulns=$(echo "$batch_results" | jq -r '.packages_with_vulns // 0')

    # Convert to osv-scanner format for prioritization
    local scanner_format=$(osv_to_scanner_format "$batch_results")

    if [[ "$PRIORITIZE" == true ]]; then
        # Create temp file with scanner format
        local temp_json=$(mktemp)
        echo "$scanner_format" > "$temp_json"
        prioritize_results "$temp_json" "$OUTPUT_FORMAT"
        rm -f "$temp_json"
    else
        # Terminal output: summary only
        echo -e "${GREEN}Vulnerability Summary:${NC}"
        echo "  Packages scanned: $packages_scanned"
        echo "  Packages with vulnerabilities: $packages_with_vulns"
        echo "  Total vulnerabilities: $total_vulns"
    fi

    # Write to output file if specified (full details for reports)
    if [[ -n "$output_file" ]]; then
        echo "$scanner_format" > "$output_file"
    fi
}

scan_sbom() {
    local sbom_file="$1"
    local output_file="$2"

    # Use batch API if enabled
    if [[ "$PARALLEL" == true ]]; then
        scan_sbom_batch "$sbom_file" "$output_file"
        return
    fi

    echo -e "${BLUE}Scanning SBOM: $sbom_file${NC}"
    echo ""

    # If prioritization is enabled, force JSON output to temp file
    if [[ "$PRIORITIZE" == true ]]; then
        local temp_json=$(mktemp)
        local temp_output=$(mktemp)

        # Run scan - osv-scanner returns exit 1 when vulnerabilities found
        osv-scanner -L "$sbom_file" --format=json > "$temp_output" 2>&1 || true

        # Extract JSON from output (skip non-JSON lines at the beginning)
        grep -A 999999 "^{" "$temp_output" > "$temp_json" 2>/dev/null || echo "{}" > "$temp_json"

        if [[ -s "$temp_json" ]] && jq empty "$temp_json" 2>/dev/null; then
            prioritize_results "$temp_json" "$OUTPUT_FORMAT"
        else
            echo -e "${RED}Error: Vulnerability scan failed or no valid JSON output${NC}"
            echo "Run without --prioritize for raw osv-scanner output"
        fi
        rm -f "$temp_json" "$temp_output"
        return
    fi

    # Normal osv-scanner output
    local cmd="osv-scanner -L $sbom_file"

    if [[ "$OUTPUT_FORMAT" != "table" ]]; then
        cmd="$cmd --format=$OUTPUT_FORMAT"
    fi

    if [[ -n "$output_file" ]]; then
        cmd="$cmd --output=$output_file"
    fi

    eval "$cmd" || true
}

# Function to run osv-scanner on repository
scan_repository() {
    local repo_path="$1"
    local output_file="$2"

    echo -e "${BLUE}Scanning repository: $repo_path${NC}"
    echo ""

    # If prioritization is enabled, force JSON output to temp file
    if [[ "$PRIORITIZE" == true ]]; then
        local temp_json=$(mktemp)
        local temp_output=$(mktemp)
        local scan_cmd="osv-scanner --recursive $repo_path"

        if [[ "$TAINT_ANALYSIS" == true ]]; then
            echo -e "${YELLOW}Enabling call graph/taint analysis...${NC}"
            scan_cmd="osv-scanner --call-analysis=all $repo_path"
        fi

        # Run scan - osv-scanner returns exit 1 when vulnerabilities found
        # Capture all output, then extract JSON (skip progress messages)
        eval "$scan_cmd --format=json" > "$temp_output" 2>&1 || true

        # Extract JSON from output (skip non-JSON lines at the beginning)
        grep -A 999999 "^{" "$temp_output" > "$temp_json" 2>/dev/null || echo "{}" > "$temp_json"

        if [[ -s "$temp_json" ]] && jq empty "$temp_json" 2>/dev/null; then
            prioritize_results "$temp_json" "$OUTPUT_FORMAT"
        else
            echo -e "${RED}Error: Vulnerability scan failed or no valid JSON output${NC}"
            echo "Run without --prioritize for raw osv-scanner output"
        fi
        rm -f "$temp_json" "$temp_output"
        return
    fi

    # Normal osv-scanner output
    local cmd="osv-scanner --recursive $repo_path"

    if [[ "$TAINT_ANALYSIS" == true ]]; then
        echo -e "${YELLOW}Enabling call graph/taint analysis...${NC}"
        cmd="osv-scanner --call-analysis=all $repo_path"
    fi

    if [[ "$OUTPUT_FORMAT" != "table" ]]; then
        cmd="$cmd --format=$OUTPUT_FORMAT"
    fi

    if [[ -n "$output_file" ]]; then
        cmd="$cmd --output=$output_file"
    fi

    eval "$cmd" || true
}

# Function to cleanup temporary files
cleanup() {
    if [[ "$CLEANUP" == true ]] && [[ -n "$TEMP_DIR" ]] && [[ -d "$TEMP_DIR" ]]; then
        echo ""
        echo -e "${YELLOW}Cleaning up temporary files...${NC}"
        rm -rf "$TEMP_DIR"
        echo -e "${GREEN}âœ“ Cleanup complete${NC}"
    fi

    # Clean up KEV cache
    if [[ -n "$KEV_CACHE" ]] && [[ -f "$KEV_CACHE" ]]; then
        rm -f "$KEV_CACHE"
    fi
}

# Ensure cleanup on script exit (normal, error, or interrupt)
trap cleanup EXIT

# Load cost tracking if using Claude
if [[ "$USE_CLAUDE" == "true" ]]; then
    REPO_ROOT="$(cd "$SCRIPT_DIR/../../.." && pwd)"
    if [ -f "$REPO_ROOT/lib/claude-cost.sh" ]; then
        source "$REPO_ROOT/lib/claude-cost.sh"
        init_cost_tracking
    fi
fi

# Parse command line arguments
OUTPUT_FILE=""
TARGET=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -t|--taint-analysis)
            TAINT_ANALYSIS=true
            shift
            ;;
        -p|--prioritize)
            PRIORITIZE=true
            shift
            ;;
        --local-path)
            LOCAL_PATH="$2"
            CLEANUP=false  # Don't cleanup externally managed directory
            shift 2
            ;;
        -f|--format)
            OUTPUT_FORMAT="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_FILE="$2"
            shift 2
            ;;
        -k|--keep-clone)
            CLEANUP=false
            shift
            ;;
        --org)
            TARGETS_LIST+=("org:$2")
            MULTI_REPO_MODE=true
            shift 2
            ;;
        --repo)
            TARGETS_LIST+=("repo:$2")
            MULTI_REPO_MODE=true
            shift 2
            ;;
        --config)
            CONFIG_FILE="$2"
            shift 2
            ;;
        --claude)
            USE_CLAUDE=true
            shift
            ;;
        --no-claude)
            USE_CLAUDE=false
            shift
            ;;
        --parallel)
            PARALLEL=true
            shift
            ;;
        --sbom)
            SBOM_FILE="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            TARGET="$1"
            shift
            ;;
    esac
done

# Determine targets: CLI args, config file, or error
if [[ "$MULTI_REPO_MODE" == false ]] && [[ -z "$TARGET" ]] && [[ ${#TARGETS_LIST[@]} -eq 0 ]]; then
    # No CLI targets, try loading from config
    if ! load_config_targets; then
        echo -e "${RED}Error: No targets specified and no config file found${NC}"
        echo ""
        echo "Specify targets via:"
        echo "  - Single target: $0 <sbom|repo-url|directory>"
        echo "  - Organization:  $0 --org myorg"
        echo "  - Repositories:  $0 --repo owner/repo1 --repo owner/repo2"
        echo "  - Config file:   Create $CONFIG_FILE with targets"
        echo ""
        exit 1
    fi
    MULTI_REPO_MODE=true
fi

# Main script
echo ""
echo "========================================="
echo "  Vulnerability Analyser (osv-scanner)"
echo "========================================="
echo ""

# Check Claude AI status first
if [[ "$USE_CLAUDE" == "true" ]] && [[ -n "$ANTHROPIC_API_KEY" ]]; then
    echo -e "${GREEN}ðŸ¤– Claude AI: ENABLED (analyzing results with AI)${NC}"
    echo ""
elif [[ -z "$ANTHROPIC_API_KEY" ]]; then
    echo -e "${YELLOW}â„¹ï¸  Claude AI: DISABLED (no API key found)${NC}"
    echo -e "${CYAN}   Set ANTHROPIC_API_KEY to enable AI-enhanced analysis${NC}"
    echo -e "${CYAN}   Get your key at: https://console.anthropic.com/settings/keys${NC}"
    echo ""
    USE_CLAUDE=false
fi

# Check prerequisites
check_osv_scanner

if [[ "$PRIORITIZE" == true ]]; then
    check_jq
    fetch_kev_catalog || echo -e "${YELLOW}Continuing without KEV data${NC}"
fi

# Show batch API hint if not using parallel mode
if [[ "$PARALLEL" != true ]]; then
    echo -e "${YELLOW}Sequential Mode: batch API disabled${NC}"
    echo ""
fi

#############################################################################
# Claude AI Analysis
#############################################################################

analyze_with_claude() {
    local data="$1"
    local model="claude-sonnet-4-20250514"

    if [[ -z "$ANTHROPIC_API_KEY" ]]; then
        echo -e "${RED}Error: ANTHROPIC_API_KEY required for --claude mode${NC}" >&2
        exit 1
    fi

    echo -e "${BLUE}Analyzing with Claude AI...${NC}" >&2

    # Load RAG knowledge for supply chain security best practices
    local rag_context=""
    local repo_root="$(cd "$SCRIPT_DIR/../../.." && pwd)"
    local rag_dir="$repo_root/rag/supply-chain"

    if [[ -f "$rag_dir/sbom-generation-best-practices.md" ]]; then
        rag_context+="# SBOM Best Practices\n\n"
        rag_context+=$(head -200 "$rag_dir/sbom-generation-best-practices.md" | tail -n +1)
        rag_context+="\n\n"
    fi

    if [[ -f "$rag_dir/package-health/package-management-best-practices.md" ]]; then
        rag_context+="# Package Management Best Practices\n\n"
        rag_context+=$(head -200 "$rag_dir/package-health/package-management-best-practices.md" | tail -n +1)
        rag_context+="\n\n"
    fi

    local prompt="You are a supply chain security expert. Analyze this vulnerability scan data and produce a PRIORITY-BASED ACTION REPORT.

# Supply Chain Security Knowledge Base
$rag_context

# Analysis Requirements

For each finding, you MUST:
1. **Explain the issue** - What is the vulnerability and why is it a problem?
2. **Justify the recommendation** - Why this action is needed based on supply chain best practices
3. **Reference knowledge base** - Cite relevant best practices from the knowledge base above
4. **Provide specific actions** - Exact commands, version numbers, or configuration changes

# Output Format

## ðŸ”´ CRITICAL PRIORITY (Immediate - 0-24 hours)
- Issues requiring immediate action (CISA KEV, Critical CVSS, active exploits)
- For each item:
  * **Issue**: [Description]
  * **Risk**: [Why this is critical]
  * **Best Practice Reference**: [Cite from knowledge base]
  * **Action**: [Specific remediation steps]
  * **Timeline**: Immediate

## ðŸŸ  HIGH PRIORITY (Urgent - 1-7 days)
- High severity issues requiring prompt attention
- Same structured format as above

## ðŸŸ¡ MEDIUM PRIORITY (Important - 1-30 days)
- Medium risk issues that should be addressed soon
- Same structured format as above

## ðŸŸ¢ LOW PRIORITY (Monitor - 30+ days)
- Low risk issues for future consideration
- Same structured format as above

## ðŸ“Š Summary & Strategic Recommendations
- Overall risk posture
- Systemic improvements based on supply chain best practices
- Automation opportunities (CI/CD integration, dependency scanning)

# Scan Data:
$data"

    local response=$(curl -s https://api.anthropic.com/v1/messages \
        -H "content-type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d "{
            \"model\": \"$model\",
            \"max_tokens\": 4096,
            \"messages\": [{
                \"role\": \"user\",
                \"content\": $(echo "$prompt" | jq -Rs .)
            }]
        }")

    if command -v record_api_usage &> /dev/null; then
        record_api_usage "$response" "$model" > /dev/null
    fi

    echo "$response" | jq -r '.content[0].text // empty'
}

# Function to analyze a single target
analyze_single_target() {
    local target="$1"
    local output_file="$2"

    # If LOCAL_PATH is set, use it instead of target
    if [[ -n "$LOCAL_PATH" ]]; then
        if [[ ! -d "$LOCAL_PATH" ]]; then
            echo -e "${RED}Error: Local path does not exist: $LOCAL_PATH${NC}"
            return 1
        fi
        echo -e "${GREEN}Target type: Local directory (provided)${NC}"
        scan_repository "$LOCAL_PATH" "$output_file"
        return $?
    fi

    # Determine target type and scan
    if is_sbom_file "$target"; then
        echo -e "${GREEN}Target type: SBOM file${NC}"
        scan_sbom "$target" "$output_file"
    elif is_git_url "$target"; then
        echo -e "${GREEN}Target type: Git repository${NC}"
        if clone_repository "$target"; then
            scan_repository "$TEMP_DIR" "$output_file"
        fi
    elif [[ -d "$target" ]]; then
        echo -e "${GREEN}Target type: Local directory${NC}"
        scan_repository "$target" "$output_file"
    else
        echo -e "${RED}Error: Invalid target${NC}"
        echo "Target must be:"
        echo "  - Path to SBOM file (.json, .xml, .cdx.*)"
        echo "  - Git repository URL"
        echo "  - Local directory path"
        return 1
    fi
}

# Capture output for Claude analysis if enabled
if [[ "$USE_CLAUDE" == "true" ]]; then
    analysis_output=$(
        # Multi-repo mode or single target
        if [[ "$MULTI_REPO_MODE" == true ]]; then
            echo "Multi-repository mode: ${#TARGETS_LIST[@]} target(s)"
            echo ""

            # Process each target
            for target_spec in "${TARGETS_LIST[@]}"; do
                if [[ "$target_spec" =~ ^org: ]]; then
                    # Expand organization to repositories
                    org="${target_spec#org:}"
                    # Extract org name from URL if provided
                    if [[ "$org" =~ github\.com/orgs/([^/]+) ]]; then
                        org="${BASH_REMATCH[1]}"
                    elif [[ "$org" =~ github\.com/([^/]+) ]]; then
                        org="${BASH_REMATCH[1]}"
                    fi
                    org="${org%/}"  # Remove trailing slashes
                    repos=$(expand_org_repos "$org" 2>&1)

                    if [[ -z "$repos" ]]; then
                        continue
                    fi

                    while IFS= read -r repo; do
                        if [[ -n "$repo" ]]; then
                            echo ""
                            echo "========================================="
                            echo "Analyzing: $repo"
                            echo "========================================="
                            echo ""
                            analyze_single_target "https://github.com/$repo" "" 2>&1
                        fi
                    done <<< "$repos"

                elif [[ "$target_spec" =~ ^repo: ]]; then
                    # Direct repository
                    repo="${target_spec#repo:}"
                    echo ""
                    echo "========================================="
                    echo "Analyzing: $repo"
                    echo "========================================="
                    echo ""
                    analyze_single_target "https://github.com/$repo" "" 2>&1
                fi
            done
        else
            # Single target mode
            analyze_single_target "$TARGET" "$OUTPUT_FILE" 2>&1
        fi
    )

    # Display original analysis
    echo "$analysis_output"

    echo ""
    echo "========================================="
    echo "  Claude AI Enhanced Analysis"
    echo "========================================="
    echo ""

    # Get Claude analysis
    claude_analysis=$(analyze_with_claude "$analysis_output")
    echo "$claude_analysis"

    # Display cost summary
    if command -v display_api_cost_summary &> /dev/null; then
        echo ""
        display_api_cost_summary
    fi
else
    # Multi-repo mode or single target
    if [[ "$MULTI_REPO_MODE" == true ]]; then
        echo -e "${BLUE}Multi-repository mode: ${#TARGETS_LIST[@]} target(s)${NC}"
        echo ""

        # Process each target
        for target_spec in "${TARGETS_LIST[@]}"; do
            if [[ "$target_spec" =~ ^org: ]]; then
                # Expand organization to repositories
                org="${target_spec#org:}"
                # Extract org name from URL if provided
                if [[ "$org" =~ github\.com/orgs/([^/]+) ]]; then
                    org="${BASH_REMATCH[1]}"
                elif [[ "$org" =~ github\.com/([^/]+) ]]; then
                    org="${BASH_REMATCH[1]}"
                fi
                org="${org%/}"  # Remove trailing slashes
                repos=$(expand_org_repos "$org")

                if [[ -z "$repos" ]]; then
                    continue
                fi

                while IFS= read -r repo; do
                    if [[ -n "$repo" ]]; then
                        echo ""
                        echo -e "${CYAN}=========================================${NC}"
                        echo -e "${CYAN}Analyzing: $repo${NC}"
                        echo -e "${CYAN}=========================================${NC}"
                        echo ""
                        analyze_single_target "https://github.com/$repo" ""
                    fi
                done <<< "$repos"

            elif [[ "$target_spec" =~ ^repo: ]]; then
                # Direct repository
                repo="${target_spec#repo:}"
                echo ""
                echo -e "${CYAN}=========================================${NC}"
                echo -e "${CYAN}Analyzing: $repo${NC}"
                echo -e "${CYAN}=========================================${NC}"
                echo ""
                analyze_single_target "https://github.com/$repo" ""
            fi
        done
    else
        # Single target mode
        analyze_single_target "$TARGET" "$OUTPUT_FILE"
    fi
fi

echo ""
echo -e "${GREEN}âœ“ Analysis Complete${NC}"

if [[ -n "$OUTPUT_FILE" ]]; then
    echo ""
    echo -e "Results saved to: ${BLUE}$OUTPUT_FILE${NC}"
fi

echo ""
