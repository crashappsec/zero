#!/bin/bash
# OSV.dev API Client Library
# Copyright (c) 2025 Crash Override Inc.
# https://crashoverride.com
# SPDX-License-Identifier: GPL-3.0
#
# Provides batch vulnerability querying via the OSV.dev API
# Supports querying multiple packages in a single request for efficiency

set -eo pipefail

# Configuration
OSV_API_BASE_URL="${OSV_API_BASE_URL:-https://api.osv.dev/v1}"
OSV_API_TIMEOUT="${OSV_API_TIMEOUT:-60}"
OSV_BATCH_SIZE="${OSV_BATCH_SIZE:-1000}"  # Max packages per batch request
OSV_MAX_RETRIES="${OSV_MAX_RETRIES:-3}"
OSV_RETRY_DELAY="${OSV_RETRY_DELAY:-2}"

# Cache configuration
OSV_CACHE_ENABLED="${OSV_CACHE_ENABLED:-true}"
OSV_CACHE_DIR="${OSV_CACHE_DIR:-/tmp/osv-cache}"
OSV_CACHE_TTL_HOURS="${OSV_CACHE_TTL_HOURS:-1}"  # Short TTL for vuln data

# Initialize cache directory
init_osv_cache() {
    if [[ "$OSV_CACHE_ENABLED" == "true" ]]; then
        mkdir -p "$OSV_CACHE_DIR"
    fi
}

# Generate cache key from query
osv_cache_key() {
    local query="$1"
    echo -n "$query" | md5sum | cut -d' ' -f1
}

# Get from cache
get_from_osv_cache() {
    local query="$1"
    local key=$(osv_cache_key "$query")
    local cache_file="$OSV_CACHE_DIR/$key.json"

    if [[ "$OSV_CACHE_ENABLED" != "true" ]]; then
        return 1
    fi

    if [[ -f "$cache_file" ]]; then
        local cache_age=$(( $(date +%s) - $(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null || echo 0) ))
        local cache_max_age=$(( OSV_CACHE_TTL_HOURS * 3600 ))

        if [[ "$cache_age" -lt "$cache_max_age" ]]; then
            cat "$cache_file"
            return 0
        fi
    fi

    return 1
}

# Save to cache
save_to_osv_cache() {
    local query="$1"
    local data="$2"
    local key=$(osv_cache_key "$query")
    local cache_file="$OSV_CACHE_DIR/$key.json"

    if [[ "$OSV_CACHE_ENABLED" == "true" ]]; then
        echo "$data" > "$cache_file"
    fi
}

# Query single package for vulnerabilities
# Usage: osv_query_package <ecosystem> <name> <version>
osv_query_package() {
    local ecosystem="$1"
    local name="$2"
    local version="$3"

    local query=$(jq -n \
        --arg eco "$ecosystem" \
        --arg name "$name" \
        --arg ver "$version" \
        '{package: {ecosystem: $eco, name: $name}, version: $ver}')

    # Check cache
    local cached
    if cached=$(get_from_osv_cache "$query"); then
        echo "$cached"
        return 0
    fi

    local attempt=1
    while [[ $attempt -le $OSV_MAX_RETRIES ]]; do
        local response
        response=$(curl -s --max-time "$OSV_API_TIMEOUT" \
            -H "Content-Type: application/json" \
            -d "$query" \
            "${OSV_API_BASE_URL}/query" 2>/dev/null)

        if [[ $? -eq 0 ]] && echo "$response" | jq empty 2>/dev/null; then
            save_to_osv_cache "$query" "$response"
            echo "$response"
            return 0
        fi

        sleep $((OSV_RETRY_DELAY * attempt))
        ((attempt++))
    done

    echo '{"vulns": [], "error": "api_request_failed"}'
    return 1
}

# Batch query vulnerabilities for multiple packages
# Usage: osv_query_batch <json_array_of_packages>
# Input format: [{"ecosystem": "npm", "name": "lodash", "version": "4.17.21"}, ...]
# Output format: {"results": [{vulns: [...]}, ...]}
osv_query_batch() {
    local packages_json="$1"
    local batch_url="${OSV_API_BASE_URL}/querybatch"

    # Build batch request
    local batch_request=$(echo "$packages_json" | jq '{
        queries: [.[] | {
            package: {
                ecosystem: .ecosystem,
                name: .name
            },
            version: .version
        }]
    }')

    # Check cache for entire batch
    local cache_key=$(osv_cache_key "$batch_request")
    local cached
    if cached=$(get_from_osv_cache "$batch_request"); then
        echo "$cached"
        return 0
    fi

    local attempt=1
    while [[ $attempt -le $OSV_MAX_RETRIES ]]; do
        local response
        response=$(curl -s --max-time "$OSV_API_TIMEOUT" \
            -H "Content-Type: application/json" \
            -d "$batch_request" \
            "$batch_url" 2>/dev/null)

        if [[ $? -eq 0 ]] && echo "$response" | jq empty 2>/dev/null; then
            # Check for error in response
            if ! echo "$response" | jq -e '.error' > /dev/null 2>&1; then
                save_to_osv_cache "$batch_request" "$response"
                echo "$response"
                return 0
            fi
        fi

        sleep $((OSV_RETRY_DELAY * attempt))
        ((attempt++))
    done

    echo '{"results": [], "error": "batch_request_failed"}'
    return 1
}

# Process SBOM and query vulnerabilities in batches
# Usage: osv_scan_sbom <sbom_json_file>
# Returns: JSON with all vulnerabilities found
osv_scan_sbom() {
    local sbom_file="$1"
    local all_vulns="[]"
    local total_packages=0
    local packages_with_vulns=0

    # Extract packages from CycloneDX SBOM
    local packages=$(jq -r '
        .components // [] |
        map(select(.type == "library")) |
        map({
            ecosystem: (
                if .purl then
                    (.purl | capture("pkg:(?<eco>[^/]+)/") | .eco) // "unknown"
                else
                    "unknown"
                end
            ),
            name: .name,
            version: .version
        }) |
        # Deduplicate by ecosystem+name+version
        unique_by("\(.ecosystem):\(.name):\(.version)")
    ' "$sbom_file" 2>/dev/null)

    if [[ -z "$packages" ]] || [[ "$packages" == "null" ]]; then
        echo '{"vulns": [], "packages_scanned": 0, "packages_with_vulns": 0}'
        return 0
    fi

    total_packages=$(echo "$packages" | jq 'length')

    # Map purl ecosystems to OSV ecosystems
    packages=$(echo "$packages" | jq '
        map(
            .ecosystem as $eco |
            .ecosystem = (
                if $eco == "npm" then "npm"
                elif $eco == "pypi" then "PyPI"
                elif $eco == "golang" then "Go"
                elif $eco == "maven" then "Maven"
                elif $eco == "cargo" then "crates.io"
                elif $eco == "gem" then "RubyGems"
                elif $eco == "nuget" then "NuGet"
                elif $eco == "packagist" then "Packagist"
                elif $eco == "pub" then "Pub"
                elif $eco == "hex" then "Hex"
                elif $eco == "cocoapods" then "CocoaPods"
                elif $eco == "hackage" then "Hackage"
                elif $eco == "cran" then "CRAN"
                elif $eco == "swift" then "SwiftURL"
                else $eco
                end
            )
        ) |
        # Filter out unknown ecosystems
        map(select(.ecosystem != "unknown"))
    ')

    local valid_packages=$(echo "$packages" | jq 'length')
    echo -e "\033[0;34mQuerying OSV for $valid_packages packages (deduplicated from $total_packages)...\033[0m" >&2

    # Process in batches
    local batch_num=0
    local offset=0

    while [[ $offset -lt $valid_packages ]]; do
        local batch=$(echo "$packages" | jq ".[$offset:$((offset + OSV_BATCH_SIZE))]")
        local batch_size=$(echo "$batch" | jq 'length')

        ((batch_num++))

        # Query batch
        local batch_results=$(osv_query_batch "$batch")

        if echo "$batch_results" | jq -e '.error' > /dev/null 2>&1; then
            echo -e "\033[0;33mWarning: Batch $batch_num failed, falling back to sequential...\033[0m" >&2
            # Fallback to sequential queries for this batch
            local i=0
            while [[ $i -lt $batch_size ]]; do
                local pkg=$(echo "$batch" | jq ".[$i]")
                local eco=$(echo "$pkg" | jq -r '.ecosystem')
                local name=$(echo "$pkg" | jq -r '.name')
                local ver=$(echo "$pkg" | jq -r '.version')

                local result=$(osv_query_package "$eco" "$name" "$ver")
                local vulns=$(echo "$result" | jq '.vulns // []')

                if [[ $(echo "$vulns" | jq 'length') -gt 0 ]]; then
                    # Add package info to each vuln
                    vulns=$(echo "$vulns" | jq --arg name "$name" --arg ver "$ver" --arg eco "$eco" '
                        map(. + {affected_package: {name: $name, version: $ver, ecosystem: $eco}})
                    ')
                    all_vulns=$(echo "$all_vulns" "$vulns" | jq -s 'add')
                    ((packages_with_vulns++))
                fi

                ((i++))
            done
        else
            # Process batch results
            local results=$(echo "$batch_results" | jq '.results // []')
            local results_len=$(echo "$results" | jq 'length')

            local i=0
            while [[ $i -lt $results_len ]]; do
                local vulns=$(echo "$results" | jq ".[$i].vulns // []")

                if [[ $(echo "$vulns" | jq 'length') -gt 0 ]]; then
                    # Get corresponding package info
                    local pkg=$(echo "$batch" | jq ".[$i]")
                    local name=$(echo "$pkg" | jq -r '.name')
                    local ver=$(echo "$pkg" | jq -r '.version')
                    local eco=$(echo "$pkg" | jq -r '.ecosystem')

                    # Add package info to each vuln
                    vulns=$(echo "$vulns" | jq --arg name "$name" --arg ver "$ver" --arg eco "$eco" '
                        map(. + {affected_package: {name: $name, version: $ver, ecosystem: $eco}})
                    ')
                    all_vulns=$(echo "$all_vulns" "$vulns" | jq -s 'add')
                    ((packages_with_vulns++))
                fi

                ((i++))
            done
        fi

        offset=$((offset + OSV_BATCH_SIZE))
    done

    # Return final results
    echo "$all_vulns" | jq --arg total "$total_packages" --arg with_vulns "$packages_with_vulns" '{
        vulns: .,
        packages_scanned: ($total | tonumber),
        packages_with_vulns: ($with_vulns | tonumber),
        total_vulns: (. | length)
    }'
}

# Convert OSV results to osv-scanner compatible format
# Usage: osv_to_scanner_format <osv_results_json>
osv_to_scanner_format() {
    local results="$1"

    echo "$results" | jq '{
        results: [
            {
                source: {path: "batch-scan", type: "sbom"},
                packages: [
                    .vulns | group_by(.affected_package.name + "@" + .affected_package.version) | .[] |
                    {
                        package: {
                            name: .[0].affected_package.name,
                            version: .[0].affected_package.version,
                            ecosystem: .[0].affected_package.ecosystem
                        },
                        vulnerabilities: map(del(.affected_package))
                    }
                ]
            }
        ]
    }'
}

# Get vulnerability details by ID
# Usage: osv_get_vuln <vuln_id>
osv_get_vuln() {
    local vuln_id="$1"

    curl -s --max-time "$OSV_API_TIMEOUT" \
        "${OSV_API_BASE_URL}/vulns/${vuln_id}" 2>/dev/null
}

# Initialize cache on load
init_osv_cache

# Export functions
export -f osv_query_package
export -f osv_query_batch
export -f osv_scan_sbom
export -f osv_to_scanner_format
export -f osv_get_vuln
export -f init_osv_cache
