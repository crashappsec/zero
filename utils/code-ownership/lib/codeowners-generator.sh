#!/bin/bash
# Copyright (c) 2024 Gibson Powers Contributors
# 
# SPDX-License-Identifier: GPL-3.0

#############################################################################
# Strategic CODEOWNERS Generator
# Intelligently generate CODEOWNERS patterns based on actual ownership
#
# Key Features:
# - Pattern detection (directory, extension, functional areas)
# - Ownership threshold configuration
# - Team-based grouping
# - Conflict resolution (multiple strong owners)
# - Pattern optimization (reduce redundancy)
# - Best practice enforcement
#############################################################################

# Generate CODEOWNERS header
generate_codeowners_header() {
    local repo_name="$1"

    cat << EOF
# CODEOWNERS
# Auto-generated by Code Ownership Analyzer
# Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
# Repository: $repo_name
#
# This file defines code ownership for automatic review requests.
# Lines are processed top-to-bottom, last match takes precedence.
#
# Pattern Format:
# <pattern> @owner1 @owner2 ...
#
# Documentation: https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners

EOF
}

# Extract GitHub username from email
extract_github_username() {
    local email="$1"

    # Try noreply email format
    if [[ "$email" =~ ^([0-9]+\+)?([^@]+)@users\.noreply\.github\.com$ ]]; then
        echo "${BASH_REMATCH[2]}"
        return 0
    fi

    # Try github.com email
    if [[ "$email" =~ ^([^@]+)@github\.com$ ]]; then
        echo "${BASH_REMATCH[1]}"
        return 0
    fi

    # Default: use email prefix
    echo "${email%%@*}"
}

# Analyze directory-level ownership
analyze_directory_ownership() {
    local repo_path="$1"
    local since_date="$2"
    local output_file="$3"
    local min_ownership="${4:-60}"  # Minimum ownership percentage to be considered

    cd "$repo_path" || return 1

    # Get all directories
    local dirs=$(find . -type d -not -path '*/\.*' | sed 's|^\./||' | sort)

    while IFS= read -r dir; do
        [[ -z "$dir" ]] && continue
        [[ "$dir" == "." ]] && continue

        # Count files in directory (non-recursive)
        local file_count=$(find "$dir" -maxdepth 1 -type f | wc -l | tr -d ' ')
        [[ $file_count -eq 0 ]] && continue

        # Get ownership by contributor for this directory
        git log --since="$since_date" --format="%ae" --name-only -- "$dir"/* 2>/dev/null | \
            grep -v "^$" | \
            awk -v dir="$dir" -v file_count="$file_count" '
            BEGIN { in_commit=1 }
            /^[a-zA-Z0-9._+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/ {
                current_email=$1
                in_commit=1
                next
            }
            in_commit && NF>0 {
                # This is a filename
                files[current_email]++
                total_files++
            }
            END {
                for (email in files) {
                    pct = (files[email] / total_files) * 100
                    printf "%s|%s|%d|%.1f\n", dir, email, files[email], pct
                }
            }' >> "$output_file"
    done <<< "$dirs"
}

# Detect file pattern ownership (by extension)
analyze_pattern_ownership() {
    local repo_path="$1"
    local since_date="$2"
    local output_file="$3"
    local min_files="${4:-3}"  # Minimum files to consider a pattern

    cd "$repo_path" || return 1

    # Get all file extensions
    local extensions=$(git ls-files | grep '\.' | sed 's/.*\.//' | sort | uniq -c | \
        awk -v min="$min_files" '$1 >= min {print $2}')

    while IFS= read -r ext; do
        [[ -z "$ext" ]] && continue

        # Get ownership for this extension
        local pattern="*.$ext"
        git log --since="$since_date" --format="%ae" --name-only -- "$pattern" 2>/dev/null | \
            grep -v "^$" | \
            awk -v pattern="$pattern" '
            /^[a-zA-Z0-9._+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/ {
                current_email=$1
                next
            }
            NF>0 {
                files[current_email]++
                total_files++
            }
            END {
                for (email in files) {
                    pct = (files[email] / total_files) * 100
                    printf "%s|%s|%d|%.1f\n", pattern, email, files[email], pct
                }
            }' >> "$output_file"
    done <<< "$extensions"
}

# Generate ownership rules from analysis
generate_ownership_rules() {
    local analysis_file="$1"
    local min_ownership="${2:-60}"  # Minimum ownership % to generate rule

    # Process analysis file and generate rules
    awk -F'|' -v min="$min_ownership" '
    {
        pattern=$1
        email=$2
        files=$3
        pct=$4

        # Only generate rule if ownership >= minimum
        if (pct >= min) {
            # Track owners for each pattern
            if (pattern in owners) {
                owners[pattern] = owners[pattern] " " email
            } else {
                owners[pattern] = email
                ownership_pct[pattern] = pct
            }
        }
    }
    END {
        # Output rules sorted by specificity
        for (pattern in owners) {
            print pattern "|" owners[pattern] "|" ownership_pct[pattern]
        }
    }' "$analysis_file" | sort -t'|' -k3 -rn
}

# Resolve conflicting owners (multiple people with strong ownership)
resolve_owner_conflicts() {
    local pattern="$1"
    local -a owners=("$@")
    shift

    # Strategy: Include all owners with >50% ownership
    # Limit to max 3 owners per pattern
    local -a final_owners=()
    local count=0

    for owner in "${owners[@]}"; do
        [[ $count -ge 3 ]] && break
        final_owners+=("@$(extract_github_username "$owner")")
        ((count++))
    done

    echo "${final_owners[@]}"
}

# Generate strategic CODEOWNERS file
generate_strategic_codeowners() {
    local repo_path="$1"
    local output_file="$2"
    local since_date="${3:-$(date -v-90d +%Y-%m-%d 2>/dev/null || date -d "90 days ago" +%Y-%m-%d)}"
    local min_ownership="${4:-60}"

    local repo_name=$(basename "$repo_path")

    # Temporary files
    local dir_analysis=$(mktemp)
    local pattern_analysis=$(mktemp)
    local all_analysis=$(mktemp)

    # Analyze directory and pattern ownership
    analyze_directory_ownership "$repo_path" "$since_date" "$dir_analysis" "$min_ownership"
    analyze_pattern_ownership "$repo_path" "$since_date" "$pattern_analysis" 3

    # Combine analyses
    cat "$dir_analysis" "$pattern_analysis" > "$all_analysis"

    # Generate CODEOWNERS file
    generate_codeowners_header "$repo_name" > "$output_file"

    # Add global default owners (top contributors)
    cat >> "$output_file" << 'EOF'
# Global Owners
# These users are owners for all files unless a more specific rule applies

EOF

    # Get top 3 contributors as default owners
    cd "$repo_path" || return 1
    git log --since="$since_date" --format="%ae" | sort | uniq -c | sort -rn | head -3 | \
        awk '{print $2}' | while read -r email; do
            local username=$(extract_github_username "$email")
            echo "# $email" >> "$output_file"
        done

    local default_owners=$(git log --since="$since_date" --format="%ae" | sort | uniq -c | sort -rn | head -3 | \
        awk '{print $2}' | while read -r email; do
            extract_github_username "$email"
        done | awk '{printf "@%s ", $1}')

    echo "* $default_owners" >> "$output_file"
    echo "" >> "$output_file"

    # Add pattern-specific rules
    cat >> "$output_file" << 'EOF'
# Pattern-Based Ownership
# Specific patterns for file types and directories

EOF

    generate_ownership_rules "$pattern_analysis" "$min_ownership" | \
        while IFS='|' read -r pattern owners_list pct; do
            # Skip very generic patterns
            [[ "$pattern" == "*" ]] && continue

            # Convert emails to GitHub usernames
            local github_owners=""
            for owner in $owners_list; do
                github_owners="$github_owners @$(extract_github_username "$owner")"
            done

            printf "%-40s %s  # %.1f%% ownership\n" "$pattern" "$github_owners" "$pct" >> "$output_file"
        done

    echo "" >> "$output_file"

    # Add directory-specific rules
    cat >> "$output_file" << 'EOF'
# Directory-Based Ownership
# Owners for specific directories

EOF

    generate_ownership_rules "$dir_analysis" "$min_ownership" | \
        while IFS='|' read -r dir owners_list pct; do
            [[ -z "$dir" ]] && continue

            # Convert to directory pattern
            local pattern="/$dir/"

            # Convert emails to GitHub usernames
            local github_owners=""
            for owner in $owners_list; do
                github_owners="$github_owners @$(extract_github_username "$owner")"
            done

            printf "%-40s %s  # %.1f%% ownership\n" "$pattern" "$github_owners" "$pct" >> "$output_file"
        done

    # Cleanup
    rm -f "$dir_analysis" "$pattern_analysis" "$all_analysis"

    echo ""
    echo "✓ Generated CODEOWNERS file: $output_file"
    echo ""
    echo "Review the file and adjust as needed before committing."
    echo "Remember:"
    echo "  - Lines are processed top-to-bottom"
    echo "  - Last matching pattern wins"
    echo "  - Consider reordering for better precedence"
}

# Validate generated CODEOWNERS
validate_generated_codeowners() {
    local codeowners_file="$1"

    local issues=0

    # Check for duplicate patterns
    local patterns=$(grep -v "^#" "$codeowners_file" | grep -v "^$" | awk '{print $1}' | sort)
    local duplicates=$(echo "$patterns" | uniq -d)

    if [[ -n "$duplicates" ]]; then
        echo "⚠️  Warning: Duplicate patterns found:"
        echo "$duplicates"
        ((issues++))
    fi

    # Check for invalid GitHub usernames
    while IFS= read -r line; do
        [[ "$line" =~ ^#.*$ ]] && continue
        [[ -z "$line" ]] && continue

        local owners=$(echo "$line" | cut -d' ' -f2-)
        for owner in $owners; do
            if [[ ! "$owner" =~ ^@[a-zA-Z0-9_-]+$ ]] && [[ ! "$owner" =~ ^@[a-zA-Z0-9_-]+/[a-zA-Z0-9_-]+$ ]]; then
                echo "⚠️  Warning: Invalid owner format: $owner"
                ((issues++))
            fi
        done
    done < "$codeowners_file"

    if [[ $issues -eq 0 ]]; then
        echo "✓ CODEOWNERS file is valid"
        return 0
    else
        echo ""
        echo "Found $issues potential issues"
        return 1
    fi
}

# Generate CODEOWNERS with team support
generate_team_based_codeowners() {
    local repo_path="$1"
    local output_file="$2"
    local team_mapping_file="$3"  # JSON: {"email": "team"}

    # Similar to generate_strategic_codeowners but groups by team
    # Implementation would map emails to team names from team_mapping_file
    echo "Team-based generation requires team mapping file"
}

# Export functions
export -f generate_codeowners_header
export -f extract_github_username
export -f analyze_directory_ownership
export -f analyze_pattern_ownership
export -f generate_ownership_rules
export -f resolve_owner_conflicts
export -f generate_strategic_codeowners
export -f validate_generated_codeowners
export -f generate_team_based_codeowners
