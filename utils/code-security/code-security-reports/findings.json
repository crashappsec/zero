[
  {
    "file": "jceks/decoder_test.go",
    "line": 31,
    "category": "secrets",
    "type": "Hardcoded Password",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded password 'store-password' used for keystore authentication in test code",
    "code_snippet": "ks, err := LoadFromFile(\"testdata/private-key.jceks\", []byte(\"store-password\"))",
    "remediation": "Use environment variables or test fixtures with randomized passwords: password := []byte(os.Getenv(\"TEST_STORE_PASSWORD\"))",
    "exploitation": "Test credentials could be reused in production or reveal password patterns"
  },
  {
    "file": "jceks/decoder_test.go",
    "line": 33,
    "category": "secrets",
    "type": "Hardcoded Password",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded password 'key-password' used for private key decryption in test code",
    "code_snippet": "key, certs, err := ks.GetPrivateKeyAndCerts(\"private-key-some-alias\", []byte(\"key-password\"))",
    "remediation": "Use environment variables: keyPassword := []byte(os.Getenv(\"TEST_KEY_PASSWORD\"))",
    "exploitation": "Hardcoded key passwords in tests may indicate weak password practices in production"
  },
  {
    "file": "jceks/decoder_test.go",
    "line": 52,
    "category": "secrets",
    "type": "Hardcoded Password",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded keystore password repeated in trusted certificate test",
    "code_snippet": "ks, err := LoadFromFile(\"testdata/trusted-cert.jceks\", []byte(\"store-password\"))",
    "remediation": "Extract password to test constants or environment variables to avoid repetition",
    "exploitation": "Password reuse across multiple test cases suggests weak security practices"
  },
  {
    "file": "jceks/decoder_test.go",
    "line": 67,
    "category": "secrets",
    "type": "Hardcoded Password",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded keystore password in LoadFromReader test",
    "code_snippet": "ks, err := LoadFromReader(f, []byte(\"store-password\"))",
    "remediation": "Use consistent password management across all test functions",
    "exploitation": "Multiple instances of the same hardcoded password increase exposure risk"
  },
  {
    "file": "jceks/decoder_test.go",
    "line": 80,
    "category": "secrets",
    "type": "Hardcoded Password",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded keystore password in Parse method test",
    "code_snippet": "err = ks.Parse(f, []byte(\"store-password\"))",
    "remediation": "Consider using a test helper function that manages passwords consistently",
    "exploitation": "Consistent hardcoded passwords across tests may indicate production usage patterns"
  },
  {
    "file": "jceks/decoder_test.go",
    "line": 99,
    "category": "secrets",
    "type": "Hardcoded Password",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-798",
    "description": "Hardcoded password in test for non-existent private key",
    "code_snippet": "sk, keyCerts, err := ks.GetPrivateKeyAndCerts(\"non-existent\", []byte(\"password\"))",
    "remediation": "Use a constant for test passwords or generate random passwords for negative tests",
    "exploitation": "Even in negative test cases, hardcoded passwords should be avoided"
  },
  {
    "file": "jceks/testdata/generate-jceks.sh",
    "line": 10,
    "category": "crypto",
    "type": "Hardcoded Credentials",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded password 'store-password' used for keystore protection",
    "code_snippet": "-keyout \"private-key-ca.key\" -out \"private-key-ca.crt\"",
    "remediation": "Use environment variables or secure password generation: openssl pkcs12 -export ... -passout \"pass:${STORE_PASSWORD:-$(openssl rand -base64 32)}\"",
    "exploitation": "Hardcoded passwords can be extracted from source code, allowing unauthorized access to keystores"
  },
  {
    "file": "jceks/testdata/generate-jceks.sh",
    "line": 17,
    "category": "crypto",
    "type": "Hardcoded Credentials",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded password 'store-password' used multiple times for PKCS12 and JCEKS keystore operations",
    "code_snippet": "-out \"private-key.p12\" -passout \"pass:store-password\"",
    "remediation": "Generate random passwords or use environment variables for production use",
    "exploitation": "Attacker can use known password to access generated keystores and extract private keys"
  },
  {
    "file": "jceks/testdata/generate-jceks.sh",
    "line": 20,
    "category": "crypto",
    "type": "Hardcoded Credentials",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded key password 'key-password' used for private key protection in keystore",
    "code_snippet": "-deststorepass \"store-password\" -destkeypass \"key-password\"",
    "remediation": "Use strong, randomly generated passwords from environment variables",
    "exploitation": "Private keys can be extracted from keystore using the hardcoded key password"
  },
  {
    "file": "jceks/testdata/generate-jceks.sh",
    "line": 10,
    "category": "crypto",
    "type": "Weak Key Generation",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-326",
    "description": "RSA 2048-bit keys may be insufficient for long-term security",
    "code_snippet": "-newkey rsa:2048",
    "remediation": "Use RSA 4096-bit keys or ECDSA P-384 for better security: -newkey rsa:4096 or -newkey ec -pkeyopt ec_paramgen_curve:P-384",
    "exploitation": "2048-bit RSA keys may become vulnerable to attacks with advancing computational power"
  },
  {
    "file": "jceks/testdata/generate-jceks.sh",
    "line": 13,
    "category": "crypto",
    "type": "Weak Key Generation",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-326",
    "description": "RSA 2048-bit key generation for private key may be insufficient",
    "code_snippet": "openssl genrsa -out \"private-key.key\" 2048",
    "remediation": "Use 4096-bit keys: openssl genrsa -out \"private-key.key\" 4096",
    "exploitation": "Smaller key sizes may be vulnerable to cryptographic attacks over time"
  },
  {
    "file": "jceks/testdata/generate-jceks.sh",
    "line": 25,
    "category": "crypto",
    "type": "Weak Key Generation",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-326",
    "description": "RSA 2048-bit keys used for trusted certificate generation",
    "code_snippet": "-newkey rsa:2048",
    "remediation": "Use stronger key sizes: -newkey rsa:4096",
    "exploitation": "Weaker key sizes reduce overall cryptographic strength of the certificate chain"
  },
  {
    "file": "jceks/testdata/generate-jceks.sh",
    "line": 29,
    "category": "crypto",
    "type": "Hardcoded Credentials",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded store password used for trusted certificate keystore",
    "code_snippet": "-deststorepass \"store-password\"",
    "remediation": "Use environment variable: -deststorepass \"${STORE_PASSWORD}\"",
    "exploitation": "Keystores can be accessed using the known hardcoded password"
  },
  {
    "file": "jceks/encoding.go",
    "line": 38,
    "category": "validation",
    "type": "Integer Overflow",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-190",
    "description": "Potential integer overflow when converting int32 to uint for comparison with maxLen",
    "code_snippet": "if uint(length) > maxLen {",
    "remediation": "Check for negative length before uint conversion: if length < 0 || uint32(length) > uint32(maxLen) {",
    "exploitation": "An attacker could provide a large negative int32 value that becomes a large positive uint, bypassing the maxLen check"
  },
  {
    "file": "jceks/encoding.go",
    "line": 45,
    "category": "validation",
    "type": "Resource Exhaustion",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-770",
    "description": "Memory allocation based on user-controlled length without sufficient validation",
    "code_snippet": "buf := make([]byte, length)",
    "remediation": "Add additional validation and consider using a streaming approach for large data: if length > reasonableLimit { return nil, ErrDataTooLarge }",
    "exploitation": "An attacker could specify a very large length value to cause excessive memory allocation, leading to denial of service"
  },
  {
    "file": "jceks/encoding.go",
    "line": 54,
    "category": "validation",
    "type": "Integer Overflow",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-190",
    "description": "Potential integer overflow when converting slice length to uint32",
    "code_snippet": "if err := binary.Write(w, binary.BigEndian, uint32(len(b))); err != nil {",
    "remediation": "Check slice length before conversion: if len(b) > math.MaxUint32 { return ErrDataTooLarge }",
    "exploitation": "On 64-bit systems, a slice longer than 4GB would cause integer overflow when cast to uint32"
  },
  {
    "file": "jceks/encoding.go",
    "line": 109,
    "category": "validation",
    "type": "Integer Overflow",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-190",
    "description": "Potential integer overflow when converting string length to uint16",
    "code_snippet": "if err := binary.Write(w, binary.BigEndian, uint16(len(str))); err != nil {",
    "remediation": "Check string length before conversion: if len(str) > math.MaxUint16 { return ErrStringTooLong }",
    "exploitation": "A string longer than 65535 bytes would cause integer overflow when cast to uint16, leading to incorrect length encoding"
  },
  {
    "file": "jceks/encoding.go",
    "line": 125,
    "category": "validation",
    "type": "Path Traversal",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-22",
    "description": "Certificate type validation only checks for exact match, may not prevent malicious certificate types",
    "code_snippet": "if certType != x509CertTag {\n    return nil, fmt.Errorf(\"%w: unable to handle certificate type: %s\", ErrUnsupportedJCEKSData, certType)",
    "remediation": "Sanitize certType before including in error message: return nil, fmt.Errorf(\"%w: unsupported certificate type\", ErrUnsupportedJCEKSData)",
    "exploitation": "An attacker could inject malicious content in the certificate type field that gets reflected in error messages, potentially causing log injection"
  },
  {
    "file": "jceks/encoding.go",
    "line": 132,
    "category": "validation",
    "type": "Denial of Service",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-400",
    "description": "Certificate parsing could consume excessive resources with malformed certificates",
    "code_snippet": "cert, err := x509.ParseCertificate(certDER)",
    "remediation": "Add timeout and size limits for certificate parsing, consider using a more restrictive parser or validation",
    "exploitation": "An attacker could provide a malformed certificate that causes the parser to consume excessive CPU or memory during parsing"
  },
  {
    "file": "jceks/decoder.go",
    "line": 327,
    "category": "crypto",
    "type": "Weak Cryptographic Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Using MD5 hash algorithm which is cryptographically broken and vulnerable to collision attacks",
    "code_snippet": "if !eKey.Algo.Algorithm.Equal(oidPBEWithMD5AndDES3CBC) {\n\t\treturn nil, fmt.Errorf(\"%w: unsupported encrypted-private-key algorithm: %v\",\n\t\t\tErrUnsupportedJCEKSData, eKey.Algo.Algorithm)\n\t}",
    "remediation": "Migrate to stronger algorithms like PBKDF2 with SHA-256 or Argon2. If backward compatibility is required, add warnings about MD5 usage and implement stronger alternatives",
    "exploitation": "Attacker could potentially exploit MD5 collision vulnerabilities to forge encrypted private keys or bypass integrity checks"
  },
  {
    "file": "jceks/decoder.go",
    "line": 327,
    "category": "crypto",
    "type": "Weak Encryption Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Using 3DES (Triple DES) encryption which has known vulnerabilities and is deprecated",
    "code_snippet": "if !eKey.Algo.Algorithm.Equal(oidPBEWithMD5AndDES3CBC) {",
    "remediation": "Replace 3DES with AES-256. Example: Use PBKDF2 with SHA-256 and AES-256-GCM for authenticated encryption",
    "exploitation": "3DES has a 64-bit block size making it vulnerable to Sweet32 attacks when large amounts of data are encrypted"
  },
  {
    "file": "jceks/decoder.go",
    "line": 186,
    "category": "validation",
    "type": "Integer Overflow",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-190",
    "description": "Potential integer overflow when converting int32 to int without bounds checking",
    "code_snippet": "for i := 0; i < int(count); i++ {",
    "remediation": "Add bounds checking: if count > math.MaxInt32 || count < 0 { return fmt.Errorf(\"invalid entry count: %d\", count) }",
    "exploitation": "Large count values could cause integer overflow leading to unexpected loop behavior or memory issues"
  },
  {
    "file": "jceks/decoder.go",
    "line": 312,
    "category": "validation",
    "type": "Integer Overflow",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-190",
    "description": "Potential integer overflow when converting signed int32 to int for certificate count",
    "code_snippet": "for j := 0; j < int(nCerts); j++ {",
    "remediation": "Add validation: if nCerts > 1000 || nCerts < 0 { return fmt.Errorf(\"invalid certificate count: %d\", nCerts) }",
    "exploitation": "Maliciously crafted JCEKS files could specify extremely large certificate counts causing memory exhaustion"
  },
  {
    "file": "jceks/decoder.go",
    "line": 334,
    "category": "crypto",
    "type": "Information Disclosure",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Generic error message may not provide enough information for legitimate debugging while attempting to prevent information leakage",
    "code_snippet": "return nil, ErrDecryptionFailed",
    "remediation": "Consider adding secure logging for debugging: log.Debug(\"Decryption failed: %v\", err) while keeping user-facing errors generic",
    "exploitation": "While this attempts to prevent information leakage, it may hinder legitimate debugging and error analysis"
  },
  {
    "file": "jceks/decoder.go",
    "line": 41,
    "category": "validation",
    "type": "Resource Exhaustion",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-770",
    "description": "Large default maximum sizes could lead to memory exhaustion with malicious input",
    "code_snippet": "defaultMaxCertBytes       = 20 * 1024 * 1024\n\tdefaultMaxPrivateKeyBytes = defaultMaxCertBytes",
    "remediation": "Consider smaller default limits and require explicit opt-in for large certificates: defaultMaxCertBytes = 1024 * 1024 // 1MB",
    "exploitation": "Attacker could craft JCEKS files with maximum-sized certificates to consume excessive memory"
  },
  {
    "file": "jceks/encoder.go",
    "line": 149,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA-1 hash algorithm is used for integrity protection, which is cryptographically weak and vulnerable to collision attacks",
    "code_snippet": "h: makeIntegrityHash(encodedPassword)",
    "remediation": "Replace SHA-1 with SHA-256 or SHA-3 for integrity protection. Example: use crypto/sha256 instead of SHA-1 in makeIntegrityHash function",
    "exploitation": "Attackers could potentially create collisions to bypass integrity checks or forge keystore data"
  },
  {
    "file": "jceks/encoder.go",
    "line": 64,
    "category": "validation",
    "type": "Insufficient Input Validation",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "Password validation only checks for basic multilingual plane but doesn't validate password strength or length",
    "code_snippet": "func (e *Encoder) SetIntegrityPassword(password string) error {\n\tintegrityPassword, err := encodeIntegrityPassword(password)\n\tif err != nil {\n\t\treturn err\n\t}",
    "remediation": "Add password strength validation: minimum length, complexity requirements. Example: if len(password) < 12 { return errors.New(\"password too short\") }",
    "exploitation": "Weak passwords could be brute-forced, compromising keystore integrity protection"
  },
  {
    "file": "jceks/encoder.go",
    "line": 314,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Error messages may expose internal implementation details or alias names that could aid attackers",
    "code_snippet": "return fmt.Errorf(\"%w: %q\", ErrDuplicateAlias, alias)",
    "remediation": "Sanitize error messages to avoid exposing sensitive information: return fmt.Errorf(\"%w\", ErrDuplicateAlias) // without alias",
    "exploitation": "Attackers could use exposed alias names or internal details for reconnaissance"
  },
  {
    "file": "jceks/encoder.go",
    "line": 267,
    "category": "validation",
    "type": "Resource Exhaustion",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-400",
    "description": "No limits on total keystore size or individual entry sizes beyond int32, could lead to memory exhaustion",
    "code_snippet": "if len(protectedKey) > math.MaxInt32 {\n\t\treturn fmt.Errorf(\"%w: protected key is too large\", ErrKeyProtectionFailed)\n\t}",
    "remediation": "Add reasonable size limits well below MaxInt32: const maxProtectedKeySize = 1024*1024; if len(protectedKey) > maxProtectedKeySize { return error }",
    "exploitation": "Attackers could cause memory exhaustion by providing very large keys or certificates"
  },
  {
    "file": "jceks/encoder.go",
    "line": 99,
    "category": "validation",
    "type": "Integer Overflow",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-190",
    "description": "Entry count increment could theoretically overflow if called enough times, though protected by MaxInt32 check later",
    "code_snippet": "e.entryCount++",
    "remediation": "Add overflow check before increment: if e.entryCount >= math.MaxUint32 { return ErrTooManyEntries }",
    "exploitation": "In theory, integer overflow could bypass entry count limits, though MaxInt32 check provides some protection"
  },
  {
    "file": "jceks/pkcs5.go",
    "line": 20,
    "category": "crypto",
    "type": "Weak Encryption Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Code uses DES (Data Encryption Standard) block size, indicating potential use of the weak DES encryption algorithm",
    "code_snippet": "import (\n\t\"bytes\"\n\t\"crypto/des\"\n\t\"crypto/subtle\"\n)\n\nfunc pkcs5Pad(ciphertext []byte) []byte {\n\tpad := byte(des.BlockSize - len(ciphertext)%des.BlockSize)",
    "remediation": "Replace DES with AES. Use crypto/aes instead: 'pad := byte(aes.BlockSize - len(ciphertext)%aes.BlockSize)' and consider using authenticated encryption modes like GCM",
    "exploitation": "DES has a 56-bit effective key length and can be brute-forced. Known plaintext attacks and differential cryptanalysis make it unsuitable for protecting sensitive data"
  },
  {
    "file": "jceks/pbemd5des3cbc.go",
    "line": 26,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "MD5 hash algorithm is cryptographically broken and vulnerable to collision attacks",
    "code_snippet": "import (\n\t\"crypto/md5\"",
    "remediation": "Replace MD5 with SHA-256 or SHA-3: import \"crypto/sha256\" and use sha256.New() instead of md5.New()",
    "exploitation": "Attackers can generate MD5 collisions to potentially derive the same key from different passwords, weakening the encryption"
  },
  {
    "file": "jceks/pbemd5des3cbc.go",
    "line": 26,
    "category": "crypto",
    "type": "Weak Encryption Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "3DES (Triple DES) encryption is deprecated and considered weak",
    "code_snippet": "import (\n\t\"crypto/des\"",
    "remediation": "Replace 3DES with AES-256: import \"crypto/aes\" and use aes.NewCipher() with 256-bit keys",
    "exploitation": "3DES has known vulnerabilities and limited 112-bit effective security, making it susceptible to cryptanalytic attacks"
  },
  {
    "file": "jceks/pbemd5des3cbc.go",
    "line": 116,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "MD5 used in key derivation function for cryptographic purposes",
    "code_snippet": "h := md5.New()\n\t\tfor range iterations {\n\t\t\th.Write(state)\n\t\t\th.Write(password)\n\t\t\tstate = h.Sum(state[:0])",
    "remediation": "Use a proper password-based key derivation function like PBKDF2 with SHA-256, scrypt, or Argon2: golang.org/x/crypto/pbkdf2.Key(password, salt, iterations, keyLen, sha256.New)",
    "exploitation": "MD5's cryptographic weaknesses in the key derivation process could allow attackers to more easily crack passwords or predict derived keys"
  },
  {
    "file": "jceks/pbemd5des3cbc.go",
    "line": 135,
    "category": "crypto",
    "type": "Weak Encryption Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Triple DES cipher initialization for encrypting private keys",
    "code_snippet": "blk, err := des.NewTripleDESCipher(desKey)",
    "remediation": "Replace with AES-256-GCM for authenticated encryption: cipher, err := aes.NewCipher(aesKey); gcm, err := cipher.NewGCM(cipher)",
    "exploitation": "3DES provides insufficient security for protecting sensitive private key material"
  },
  {
    "file": "jceks/pbemd5des3cbc.go",
    "line": 188,
    "category": "crypto",
    "type": "Weak Encryption Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Triple DES cipher used for decrypting private keys",
    "code_snippet": "blk, err := des.NewTripleDESCipher(desKey)",
    "remediation": "Replace with AES-256-GCM: cipher, err := aes.NewCipher(aesKey); gcm, err := cipher.NewGCM(cipher)",
    "exploitation": "Weak encryption algorithm protecting private key material during decryption"
  },
  {
    "file": "jceks/pbemd5des3cbc.go",
    "line": 108,
    "category": "crypto",
    "type": "Weak Key Derivation",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Custom key derivation function using deprecated MD5 instead of standard PBKDF2",
    "code_snippet": "func derivePBEWithMD5AndDES3CBCParams(password []byte, salt []byte, iterations uint) (key []byte, iv []byte)",
    "remediation": "Use standard PBKDF2 with SHA-256: pbkdf2.Key(password, salt, int(iterations), keyLen, sha256.New)",
    "exploitation": "Non-standard key derivation may have implementation weaknesses and uses cryptographically broken MD5"
  },
  {
    "file": "jceks/pkcs5_test.go",
    "line": 58,
    "category": "crypto",
    "type": "Padding Oracle Attack Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "PKCS5 unpadding returns specific error information that could enable padding oracle attacks if exposed to attackers",
    "code_snippet": "_, err := pkcs5Unpad(tc.in)\n\t\t\trequire.Error(t, err)\n\t\t\trequire.ErrorIs(t, err, ErrInvalidCiphertext)",
    "remediation": "Ensure the production implementation uses constant-time operations and returns generic error messages. Consider using authenticated encryption (AES-GCM) instead of CBC+PKCS5 to prevent padding oracle attacks entirely.",
    "exploitation": "If the specific error conditions are exposed to attackers through timing or error messages, they could perform padding oracle attacks to decrypt ciphertext without the key"
  },
  {
    "file": "jceks/pkcs5_test.go",
    "line": 20,
    "category": "crypto",
    "type": "Weak Block Size",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-327",
    "description": "Code uses 8-byte block size which suggests DES encryption (64-bit blocks) rather than AES (128-bit blocks)",
    "code_snippet": "{in: []byte{}, expected: []byte{8, 8, 8, 8, 8, 8, 8, 8}}",
    "remediation": "Use AES encryption with 16-byte blocks instead of DES. Update PKCS5 padding to work with 16-byte block size: []byte{16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16}",
    "exploitation": "DES encryption with 8-byte blocks is cryptographically weak and can be broken with sufficient computational resources"
  },
  {
    "file": "jceks/pbemd5des3cbc_test.go",
    "line": 84,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "MD5 hash algorithm is cryptographically broken and vulnerable to collision attacks",
    "code_snippet": "_, err := PBEWithMD5AndDES3CBC([]byte(\"CHANGE\"), rnd, 0)",
    "remediation": "Replace MD5 with SHA-256 or better: use PBKDF2 with SHA-256, Argon2, or bcrypt for password-based key derivation",
    "exploitation": "MD5 collisions can be generated in seconds, allowing attackers to create different inputs that produce the same hash"
  },
  {
    "file": "jceks/pbemd5des3cbc_test.go",
    "line": 87,
    "category": "crypto",
    "type": "Weak Encryption Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "3DES (Triple DES) encryption is deprecated due to small block size and potential vulnerabilities",
    "code_snippet": "_, err = PBEWithMD5AndDES3CBC([]byte(\"CHANGE\"), rnd, math.MaxInt)",
    "remediation": "Replace 3DES with AES-256-GCM: use AES with 256-bit keys in GCM mode for authenticated encryption",
    "exploitation": "3DES has a 64-bit block size making it vulnerable to birthday attacks and Sweet32 attacks with sufficient data"
  },
  {
    "file": "jceks/pbemd5des3cbc_test.go",
    "line": 140,
    "category": "crypto",
    "type": "Weak Iteration Count",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-916",
    "description": "Using very low iteration count (1) for password-based key derivation makes brute force attacks feasible",
    "code_snippet": "iterations: 1,",
    "remediation": "Use minimum 100,000 iterations for PBKDF2, preferably 200,000+: iterations: 200000",
    "exploitation": "Low iteration counts allow attackers to quickly brute force passwords using dictionary or rainbow table attacks"
  },
  {
    "file": "jceks/pbemd5des3cbc_test.go",
    "line": 158,
    "category": "crypto",
    "type": "Insecure Salt",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-760",
    "description": "Using predictable salt with repeated bytes reduces cryptographic strength",
    "code_snippet": "salt:       []byte{0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7},",
    "remediation": "Generate cryptographically random salt: salt := make([]byte, 16); rand.Read(salt)",
    "exploitation": "Predictable salts enable rainbow table attacks and reduce the effectiveness of key derivation"
  },
  {
    "file": "jceks/pbemd5des3cbc_test.go",
    "line": 31,
    "category": "crypto",
    "type": "Weak Password Policy",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-521",
    "description": "Test accepts single space character as valid password, which is extremely weak",
    "code_snippet": "password: \" \",\nok:       true,",
    "remediation": "Implement minimum password requirements: length >= 12, mixed case, numbers, special characters",
    "exploitation": "Single character passwords can be cracked instantly through brute force attacks"
  },
  {
    "file": "jceks/jceks_test.go",
    "line": 18,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA-1 hash algorithm is used, which has known collision vulnerabilities and is considered cryptographically weak",
    "code_snippet": "\"crypto/sha1\"",
    "remediation": "Replace SHA-1 with a stronger hash algorithm like SHA-256 or SHA-3. Example: import \"crypto/sha256\" and use sha256.Sum256() instead of sha1.Sum()",
    "exploitation": "While this appears to be test code, using SHA-1 in production could allow attackers to create hash collisions, potentially compromising integrity verification"
  },
  {
    "file": "jceks/jceks.go",
    "line": 29,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA-1 is used for JCEKS integrity verification. SHA-1 is cryptographically broken with known collision attacks.",
    "code_snippet": "\"crypto/sha1\"",
    "remediation": "While JCEKS format mandates SHA-1, consider warning users about the weak cryptography or migrating to more secure keystore formats like PKCS#12 with stronger hash algorithms.",
    "exploitation": "Attackers could potentially create malicious keystores that pass integrity checks due to SHA-1 collision vulnerabilities"
  },
  {
    "file": "jceks/jceks.go",
    "line": 81,
    "category": "validation",
    "type": "Missing Input Validation",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "No validation of maxAliasLen constant usage or bounds checking for alias length processing",
    "code_snippet": "maxAliasLen = 0xFFFF",
    "remediation": "Ensure alias length validation is properly implemented: if aliasLen > maxAliasLen { return fmt.Errorf(\"alias too long: %d\", aliasLen) }",
    "exploitation": "Large alias lengths could potentially cause memory exhaustion or buffer overflow attacks"
  },
  {
    "file": "jceks/jceks.go",
    "line": 108,
    "category": "validation",
    "type": "Integer Overflow Risk",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-190",
    "description": "Unicode codepoint validation uses math.MaxUint16 but doesn't check for potential overflow in binary.BigEndian.AppendUint16",
    "code_snippet": "if r > math.MaxUint16 {\n\t\t\treturn nil, fmt.Errorf(\"%w: password contains unsupported codepoints\", ErrInvalidPassword)\n\t\t}",
    "remediation": "Add explicit bounds checking: if len(password)*2 > maxPasswordLen { return nil, ErrPasswordTooLong }",
    "exploitation": "Very long passwords could potentially cause integer overflow in password encoding"
  },
  {
    "file": "jceks/jceks.go",
    "line": 121,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Function explicitly creates SHA-1 hash for integrity verification, perpetuating use of broken cryptographic algorithm",
    "code_snippet": "h := sha1.New()\n\th.Write(encodedPassword)\n\th.Write([]byte(jceksIntegrityMagic))",
    "remediation": "Document the security limitation and consider adding warnings: // WARNING: SHA-1 is cryptographically broken but required by JCEKS format\nlog.Warn(\"Using SHA-1 for keystore integrity - consider migrating to PKCS#12\")",
    "exploitation": "Integrity verification using SHA-1 is vulnerable to collision attacks, allowing malicious keystores to appear valid"
  },
  {
    "file": "jceks/jceks.go",
    "line": 100,
    "category": "validation",
    "type": "Missing Length Validation",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "No maximum length validation for password input could lead to resource exhaustion",
    "code_snippet": "func encodeIntegrityPassword(password string) ([]byte, error) {",
    "remediation": "Add password length validation: const maxPasswordLen = 1024; if len(password) > maxPasswordLen { return nil, ErrPasswordTooLong }",
    "exploitation": "Extremely long passwords could consume excessive memory during encoding"
  },
  {
    "file": "jceks/encoder_test.go",
    "line": 24,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA-1 is used for cryptographic operations. SHA-1 has known collision vulnerabilities and should not be used for security-sensitive applications.",
    "code_snippet": "\"crypto/sha1\"",
    "remediation": "Replace SHA-1 with SHA-256 or SHA-3: import \"crypto/sha256\" and use sha256.Sum256() instead of sha1.Sum()",
    "exploitation": "Attackers could potentially generate hash collisions to bypass integrity checks or forge signatures"
  },
  {
    "file": "jceks/keytool_test.go",
    "line": 78,
    "category": "injection",
    "type": "Command Injection",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-78",
    "description": "User-controlled file paths are passed directly to external commands without validation or sanitization",
    "code_snippet": "err := exec.Command(\"openssl\", \"pkcs12\",\n\t\t\"-export\",\n\t\t\"-in\", \"testdata/private-key.crt\",\n\t\t\"-inkey\", \"testdata/private-key.key\",\n\t\t\"-certfile\", \"testdata/private-key-ca.crt\",\n\t\t\"-name\", \"test-private-key\",\n\t\t\"-passout\", \"pass:store-password\",\n\t\t\"-out\", p12Filename,\n\t).Run()",
    "remediation": "Validate file paths and use absolute paths or restrict to safe directories: filepath.Clean(p12Filename) and verify it's within expected directory bounds",
    "exploitation": "An attacker who can control the random filename generation could potentially create files in unintended locations or inject command arguments"
  },
  {
    "file": "jceks/keytool_test.go",
    "line": 87,
    "category": "injection",
    "type": "Command Injection",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-78",
    "description": "User-controlled file paths passed to keytool command without validation",
    "code_snippet": "err = exec.Command(\"keytool\", \"-importkeystore\",\n\t\t\"-alias\", \"test-private-key\",\n\t\t\"-srckeystore\", p12Filename,\n\t\t\"-srcstoretype\", \"PKCS12\",\n\t\t\"-srcstorepass\", \"store-password\",\n\t\t\"-destkeystore\", jceksFilename,\n\t\t\"-storetype\", \"JCEKS\",\n\t\t\"-deststorepass\", \"store-password\",\n\t\t\"-destkeypass\", \"key-password\",\n\t).Run()",
    "remediation": "Validate and sanitize file paths before passing to external commands. Use filepath.Clean() and verify paths are within expected boundaries",
    "exploitation": "Malicious filenames could be used to write files to arbitrary locations or inject additional command-line arguments"
  },
  {
    "file": "jceks/keytool_test.go",
    "line": 97,
    "category": "injection",
    "type": "Command Injection",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-78",
    "description": "File paths passed to keytool without validation in certificate import command",
    "code_snippet": "err = exec.Command(\"keytool\", \"-importcert\",\n\t\t\"-noprompt\",\n\t\t\"-alias\", \"test-trusted-cert\",\n\t\t\"-file\", \"testdata/trusted-cert.crt\",\n\t\t\"-destkeystore\", jceksFilename,\n\t\t\"-storetype\", \"JCEKS\",\n\t\t\"-deststorepass\", \"store-password\",\n\t).Run()",
    "remediation": "Validate file paths before passing to external commands and ensure they cannot be manipulated to inject arguments",
    "exploitation": "Attacker could potentially manipulate file paths to inject command arguments or access unintended files"
  },
  {
    "file": "jceks/keytool_test.go",
    "line": 59,
    "category": "crypto",
    "type": "Weak Random Number Generation",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-330",
    "description": "Using math/rand for filename generation in security-sensitive context",
    "code_snippet": "p12Filename := filepath.Join(os.TempDir(), \"jceks-test-\"+strconv.FormatUint(rand.Uint64(), 16)+\".p12\")\n\tjceksFilename := filepath.Join(os.TempDir(), \"jceks-test-\"+strconv.FormatUint(rand.Uint64(), 16)+\".jceks\")",
    "remediation": "Use crypto/rand for generating temporary filenames: import \"crypto/rand\"; use rand.Int() or create a secure random string generator",
    "exploitation": "Predictable filenames could lead to race conditions or allow attackers to predict and potentially interfere with test files"
  },
  {
    "file": "jceks/keytool_test.go",
    "line": 203,
    "category": "injection",
    "type": "Command Injection",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-78",
    "description": "Multiple keytool and openssl commands using unvalidated file paths",
    "code_snippet": "err = exec.Command(\"keytool\", \"-importkeystore\",\n\t\t\"-srckeystore\", jceksFilename,\n\t\t\"-srcstoretype\", \"JCEKS\",\n\t\t\"-srcstorepass\", \"store-password\",\n\t\t\"-destkeystore\", p12Filename,\n\t\t\"-storetype\", \"PKCS12\",\n\t\t\"-deststorepass\", \"store-password\"",
    "remediation": "Implement path validation function to ensure file paths are safe and cannot be used for argument injection",
    "exploitation": "File path manipulation could lead to command injection or unintended file operations"
  },
  {
    "file": "jceks/keytool_test.go",
    "line": 78,
    "category": "secrets",
    "type": "Hardcoded Credentials",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-798",
    "description": "Hardcoded passwords used in test commands",
    "code_snippet": "\"-passout\", \"pass:store-password\"",
    "remediation": "While acceptable for tests, ensure these hardcoded passwords are never used in production code. Consider using constants or generating random passwords for tests",
    "exploitation": "In test context this is acceptable, but pattern should not be copied to production code"
  },
  {
    "file": "jceks/modutf8.go",
    "line": 50,
    "category": "validation",
    "type": "Resource Exhaustion",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-770",
    "description": "Unbounded memory allocation in strings.Builder without input size validation",
    "code_snippet": "var sb strings.Builder\nbuf := make([]byte, 6)\nfor {\n    // ... reads and appends to sb indefinitely",
    "remediation": "Add input size limits and bounds checking: const maxStringSize = 1024 * 1024; if sb.Len() > maxStringSize { return \"\", errors.New(\"string too large\") }",
    "exploitation": "Attacker can provide malicious JCEKS data with very large strings to cause excessive memory consumption and potential DoS"
  },
  {
    "file": "internal/gen-known-logs/main.go",
    "line": 46,
    "category": "validation",
    "type": "Server-Side Request Forgery (SSRF)",
    "severity": "high",
    "confidence": "medium",
    "cwe": "CWE-918",
    "description": "HTTP request made to hardcoded URL without validation or timeout controls",
    "code_snippet": "resp, err := http.Get(knownLogsAddr)",
    "remediation": "Use http.Client with timeout and validate URL: client := &http.Client{Timeout: 10 * time.Second}; resp, err := client.Get(knownLogsAddr)",
    "exploitation": "If knownLogsAddr is modified maliciously, could be used to make requests to internal services"
  },
  {
    "file": "internal/gen-known-logs/main.go",
    "line": 46,
    "category": "config",
    "type": "Missing Timeout Configuration",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-400",
    "description": "HTTP client used without timeout, potentially causing indefinite hangs",
    "code_snippet": "resp, err := http.Get(knownLogsAddr)",
    "remediation": "client := &http.Client{Timeout: 30 * time.Second}; resp, err := client.Get(knownLogsAddr)",
    "exploitation": "Slow or unresponsive server could cause the application to hang indefinitely"
  },
  {
    "file": "internal/gen-known-logs/main.go",
    "line": 74,
    "category": "validation",
    "type": "Path Traversal",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-22",
    "description": "File created using user-controlled path without validation",
    "code_snippet": "f, err := os.Create(*out)",
    "remediation": "Validate and sanitize the output path: if !filepath.IsAbs(*out) || strings.Contains(*out, \"..\") { log.Fatal(\"Invalid output path\") }",
    "exploitation": "Attacker could specify paths like '../../../etc/passwd' to write files outside intended directory"
  },
  {
    "file": "internal/gen-known-logs/main.go",
    "line": 85,
    "category": "injection",
    "type": "Code Generation Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-94",
    "description": "External data from HTTP response used in code generation without sanitization",
    "code_snippet": "fmt.Fprintf(f, \"\\t%q: {operator: %q, url: %q},\\n\", l.ID, op.Name, l.URL)",
    "remediation": "Validate and sanitize all data before code generation or use text/template with proper escaping",
    "exploitation": "Malicious CT log data could inject arbitrary code into generated Go source file"
  },
  {
    "file": "cli/terminal/terminal.go",
    "line": 69,
    "category": "exposure",
    "type": "Information Leakage",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Error details from os.OpenFile are exposed to stderr, potentially revealing internal system information",
    "code_snippet": "tty, err := os.OpenFile(\"/dev/tty\", os.O_RDWR, 0)\n\tif err != nil {\n\t\ttty = os.Stdin\n\t}",
    "remediation": "Log the error internally but don't expose detailed error messages to users. Use a generic fallback message.",
    "exploitation": "Attackers could gain information about the system's file system structure or permission setup from detailed error messages"
  },
  {
    "file": "cli/terminal/terminal.go",
    "line": 83,
    "category": "exposure",
    "type": "Error Information Disclosure",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Detailed error information from terminal.ReadPassword is written to stderr and may expose sensitive system details",
    "code_snippet": "password, err := terminal.ReadPassword(int(tty.Fd()))\n\t_, _ = tty.WriteString(\"\\n\")\n\tif err != nil {\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"error reading password: %s\\n\", err)\n\t\tos.Exit(1)\n\t}",
    "remediation": "Use generic error message: fmt.Fprintf(os.Stderr, \"Failed to read password\\n\")",
    "exploitation": "Error messages could reveal information about terminal capabilities, file descriptors, or system configuration that aids in reconnaissance"
  },
  {
    "file": "cli/terminal/terminal.go",
    "line": 57,
    "category": "exposure",
    "type": "Sensitive Data in Memory",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-316",
    "description": "Default password is stored as a string pointer without secure memory handling, potentially leaving traces in memory",
    "code_snippet": "func (t *TTY) SetDefaultPassword(password string) {\n\tt.defaultPassword = &password\n}",
    "remediation": "Consider using a byte slice and clearing it after use: defer func() { for i := range passwordBytes { passwordBytes[i] = 0 } }()",
    "exploitation": "Memory dumps or swap files could potentially expose the default password if the memory is not properly cleared"
  },
  {
    "file": "cli/terminal/terminal.go",
    "line": 86,
    "category": "config",
    "type": "Hard Exit on Error",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-248",
    "description": "Application calls os.Exit(1) directly, preventing proper cleanup and graceful error handling",
    "code_snippet": "if err != nil {\n\t\t_, _ = fmt.Fprintf(os.Stderr, \"error reading password: %s\\n\", err)\n\t\tos.Exit(1)\n\t}",
    "remediation": "Return an error instead of calling os.Exit: return \"\", fmt.Errorf(\"failed to read password\")",
    "exploitation": "Prevents graceful shutdown procedures, resource cleanup, and proper error handling by calling code"
  },
  {
    "file": "cli/terminal/testing.go",
    "line": 31,
    "category": "exposure",
    "type": "Sensitive Data in Memory",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-316",
    "description": "Password stored in plain text in struct field without any protection or clearing mechanism",
    "code_snippet": "Password  string",
    "remediation": "Consider using a secure string type that clears memory after use, or implement a method to clear the password field after testing: func (t *TestTerminal) ClearPassword() { t.Password = \"\" }",
    "exploitation": "In testing environments, passwords may remain in memory longer than necessary, potentially accessible through memory dumps or core dumps"
  },
  {
    "file": "cli/terminal/testing.go",
    "line": 46,
    "category": "exposure",
    "type": "Password Storage in Testing",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-256",
    "description": "SetDefaultPassword stores password in plain text without any warning or security considerations",
    "code_snippet": "func (t *TestTerminal) SetDefaultPassword(password string) {\n\tt.Password = password\n}",
    "remediation": "Add documentation warning that this is for testing only and should never be used with real passwords. Consider adding a prefix check to ensure only test passwords are used: if !strings.HasPrefix(password, \"test-\") { panic(\"only test passwords allowed\") }",
    "exploitation": "If accidentally used in production, real passwords could be stored in plain text"
  },
  {
    "file": "cli/cli.go",
    "line": 80,
    "category": "injection",
    "type": "Command Injection",
    "severity": "high",
    "confidence": "medium",
    "cwe": "CWE-78",
    "description": "User-controlled input from connectTo is used in network operations without proper validation, potentially allowing injection attacks",
    "code_snippet": "connectTo = connect.Arg(\"server[:port]\", \"Hostname or IP to connect to, with optional port.\").Required().String()",
    "remediation": "Validate and sanitize the server input using proper hostname/IP validation and port range checks before use",
    "exploitation": "Attacker could potentially inject malicious hostnames or exploit parsing logic if the input is used in shell commands or other contexts"
  },
  {
    "file": "cli/cli.go",
    "line": 169,
    "category": "validation",
    "type": "Path Traversal",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-22",
    "description": "File paths from user input are opened without sufficient validation against path traversal attacks",
    "code_snippet": "rawFile, err := os.Open(fileName)",
    "remediation": "Validate file paths to prevent directory traversal: filepath.Clean(fileName) and check if the resolved path is within allowed directories",
    "exploitation": "Attacker could use relative paths like '../../../etc/passwd' to read files outside intended directories"
  },
  {
    "file": "cli/cli.go",
    "line": 322,
    "category": "validation",
    "type": "Path Traversal",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-22",
    "description": "Multiple file paths from user input are opened without sufficient validation against path traversal attacks",
    "code_snippet": "rawFile, err := os.Open(filename)",
    "remediation": "Validate file paths to prevent directory traversal: filepath.Clean(filename) and check if the resolved path is within allowed directories",
    "exploitation": "Attacker could use relative paths like '../../../etc/passwd' to read files outside intended directories"
  },
  {
    "file": "cli/cli.go",
    "line": 109,
    "category": "exposure",
    "type": "Sensitive Data in Logs",
    "severity": "medium",
    "confidence": "low",
    "cwe": "CWE-532",
    "description": "Password input may be logged or exposed through error handling mechanisms",
    "code_snippet": "dumpPassword = dump.Flag(\"password\", \"Password for PKCS12/JCEKS key stores (reads from TTY if missing).\").Short('p').String()",
    "remediation": "Ensure password flags are marked as sensitive and not logged. Use secure input methods and clear password from memory after use",
    "exploitation": "Passwords could be exposed in command history, process lists, or debug output"
  },
  {
    "file": "cli/cli.go",
    "line": 268,
    "category": "validation",
    "type": "Server-Side Request Forgery (SSRF)",
    "severity": "high",
    "confidence": "medium",
    "cwe": "CWE-918",
    "description": "User-controlled server address used in network connections without validation could allow SSRF attacks",
    "code_snippet": "connState, cri, err := starttls.GetConnectionState(*connectStartTLS, *connectName, *connectTo, *connectIdentity, *connectCert, *connectKey, *connectProxy, *connectTimeout)",
    "remediation": "Validate connectTo input to ensure it's a legitimate external server. Block internal IP ranges (127.0.0.0/8, 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) and localhost",
    "exploitation": "Attacker could force the application to connect to internal services like 127.0.0.1:6379 (Redis) or cloud metadata services"
  },
  {
    "file": "cli/cli.go",
    "line": 129,
    "category": "validation",
    "type": "Improper Input Validation",
    "severity": "medium",
    "confidence": "low",
    "cwe": "CWE-20",
    "description": "Timeout duration from user input is parsed without bounds checking",
    "code_snippet": "connectTimeout = connect.Flag(\"timeout\", \"Timeout for connecting to remote server (can be '5m', '1s', etc).\").Default(\"5s\").Duration()",
    "remediation": "Add validation for timeout duration to ensure reasonable bounds (e.g., minimum 1s, maximum 5m) to prevent resource exhaustion",
    "exploitation": "Attacker could set extremely long timeouts causing resource exhaustion or denial of service"
  },
  {
    "file": "cli/cli_test.go",
    "line": 45,
    "category": "crypto",
    "type": "Hardcoded Cryptographic Keys",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-321",
    "description": "Private key hardcoded in source code as a byte array constant",
    "code_snippet": "var localhostKey = []byte(`-----BEGIN PRIVATE KEY-----\nMIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgoAW3yvL3JJBzaAdG\naPJ9zriULhC+a9ODMQTM1vWBGVahRANCAATM99XdCMWptOjjx1INxFJSLhcqrFGI\nzXSfNNpL0EpPhsjkl2rLYBo7mNvUBz2pSTMkHA8emmVeBGr748DsMQHG\n-----END PRIVATE KEY-----`)",
    "remediation": "Generate test keys dynamically during test execution or load from environment variables. For test files, consider using crypto/rand to generate ephemeral keys:\n\nfunc generateTestKey() (*ecdsa.PrivateKey, error) {\n    return ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n}",
    "exploitation": "If this test code is deployed or the repository is compromised, the private key could be extracted and used to impersonate the localhost certificate"
  },
  {
    "file": "cli/cli_test.go",
    "line": 177,
    "category": "config",
    "type": "Insecure TLS Configuration",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-295",
    "description": "Test server uses hardcoded certificate which may lead to improper certificate validation testing",
    "code_snippet": "ts.TLS.Certificates = []tls.Certificate{cert}",
    "remediation": "Ensure test scenarios properly validate certificate chains and don't bypass security checks:\n\n// Generate fresh certificates for each test\nfunc setupTestTLS(t *testing.T) *httptest.Server {\n    cert, key := generateTestCertificate(t)\n    tlsCert, err := tls.X509KeyPair(cert, key)\n    require.NoError(t, err)\n    \n    ts := httptest.NewUnstartedServer(handler)\n    ts.TLS = &tls.Config{Certificates: []tls.Certificate{tlsCert}}\n    ts.StartTLS()\n    return ts\n}",
    "exploitation": "Test scenarios using hardcoded certificates may not properly validate real-world certificate validation logic"
  },
  {
    "file": "cli/cli_test.go",
    "line": 156,
    "category": "validation",
    "type": "Path Traversal in Test",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-22",
    "description": "Test creates temporary files without validating the path could be manipulated in certain test environments",
    "code_snippet": "tmpfile, err := os.CreateTemp(\"\", t.Name())",
    "remediation": "While this is in test code, ensure proper path validation:\n\n// Use a dedicated test directory\ntestDir := filepath.Join(os.TempDir(), \"certigo-tests\")\nerr := os.MkdirAll(testDir, 0700)\nrequire.NoError(t, err)\n\ntmpfile, err := os.CreateTemp(testDir, \"test-cert-*.pem\")\nrequire.NoError(t, err)\ndefer os.Remove(tmpfile.Name())",
    "exploitation": "In compromised test environments, temporary file creation could potentially be manipulated"
  },
  {
    "file": "starttls/starttls.go",
    "line": 55,
    "category": "crypto",
    "type": "Insecure TLS Configuration",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-295",
    "description": "TLS certificate verification is completely disabled with InsecureSkipVerify: true, making connections vulnerable to man-in-the-middle attacks",
    "code_snippet": "conf := &tls.Config{\n\t\t// We verify later manually so we can print results\n\t\tInsecureSkipVerify: true,",
    "remediation": "Enable certificate verification: InsecureSkipVerify: false, or implement proper manual verification immediately after connection",
    "exploitation": "Attacker can intercept TLS connections using invalid/self-signed certificates, potentially stealing sensitive data like database credentials"
  },
  {
    "file": "starttls/starttls.go",
    "line": 58,
    "category": "crypto",
    "type": "Weak TLS Version",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Minimum TLS version set to TLS 1.0, which has known vulnerabilities and should be deprecated",
    "code_snippet": "MinVersion:         tls.VersionTLS10,",
    "remediation": "Use a secure minimum TLS version: MinVersion: tls.VersionTLS12",
    "exploitation": "TLS 1.0 is vulnerable to attacks like BEAST and POODLE, allowing attackers to decrypt communications"
  },
  {
    "file": "starttls/starttls.go",
    "line": 228,
    "category": "injection",
    "type": "SQL Connection String Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-89",
    "description": "User-controlled identity parameter is directly concatenated into MySQL connection string without validation",
    "code_snippet": "state, err = mysql.DumpTLS(fmt.Sprintf(\"%s@tcp(%s)/?tls=certigo&timeout=%s\", identity, addr, timeout.String()))",
    "remediation": "Validate and sanitize the identity parameter before use: if !regexp.MustCompile(`^[a-zA-Z0-9_]+$`).MatchString(identity) { return nil, nil, errors.New(\"invalid identity\") }",
    "exploitation": "Malicious identity values could potentially inject MySQL connection parameters or cause connection errors"
  },
  {
    "file": "starttls/starttls.go",
    "line": 235,
    "category": "injection",
    "type": "SQL Connection String Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-89",
    "description": "User-controlled identity parameter is directly concatenated into PostgreSQL connection string without validation",
    "code_snippet": "uri := fmt.Sprintf(\"postgres://%s@%s/?sslmode=require&connect_timeout=%d\", identity, addr, timeout/time.Second)",
    "remediation": "Validate the identity parameter and use URL encoding: identity = url.QueryEscape(identity) before concatenation",
    "exploitation": "Attacker could inject PostgreSQL connection parameters by providing malicious identity values containing special characters"
  },
  {
    "file": "starttls/starttls.go",
    "line": 238,
    "category": "injection",
    "type": "Path Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-22",
    "description": "Client certificate and key file paths are used without validation, potentially allowing access to arbitrary files",
    "code_snippet": "if clientCert != \"\" {\n\t\t\t\turi += fmt.Sprintf(\"&sslcert=%s\", clientCert)\n\t\t\t}\n\t\t\tif clientKey != \"\" {\n\t\t\t\turi += fmt.Sprintf(\"&sslkey=%s\", clientCert)",
    "remediation": "Validate file paths and restrict to allowed directories: filepath.Clean(clientCert) and check if path is within allowed directory",
    "exploitation": "Attacker could access sensitive files outside intended directories by providing path traversal sequences like '../../../etc/passwd'"
  },
  {
    "file": "starttls/starttls.go",
    "line": 241,
    "category": "validation",
    "type": "Logic Error",
    "severity": "low",
    "confidence": "high",
    "description": "Bug in SSL key parameter - uses clientCert value instead of clientKey",
    "code_snippet": "uri += fmt.Sprintf(\"&sslkey=%s\", clientCert)",
    "remediation": "Fix the parameter to use the correct variable: uri += fmt.Sprintf(\"&sslkey=%s\", clientKey)",
    "exploitation": "Could cause SSL authentication failures when client certificates are used"
  },
  {
    "file": "starttls/starttls.go",
    "line": 148,
    "category": "validation",
    "type": "Resource Leak",
    "severity": "low",
    "confidence": "medium",
    "description": "Potential goroutine leak due to timeout goroutine that may not be cleaned up",
    "code_snippet": "go func() {\n\t\t<-time.After(timeout)\n\t\tres <- connectResult{nil, errors.New(\"timed out\")}\n\t}()",
    "remediation": "Use context.WithTimeout for proper cancellation: ctx, cancel := context.WithTimeout(context.Background(), timeout); defer cancel()",
    "exploitation": "Long-running applications could accumulate goroutines leading to memory leaks"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 106,
    "category": "injection",
    "type": "Format String Vulnerability",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-134",
    "description": "The errorf function is called with user-controlled input that could contain format string specifiers",
    "code_snippet": "errorf(\"%s\", err)",
    "remediation": "Use proper format string handling or ensure user input cannot contain format specifiers: errorf(\"parsing error: %v\", err)",
    "exploitation": "If error messages contain user input with format specifiers like %s, %x, this could lead to information disclosure"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 144,
    "category": "injection",
    "type": "Format String Vulnerability",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-134",
    "description": "The errorf function is called with user-controlled input that could contain format string specifiers",
    "code_snippet": "errorf(\"%s\", err)",
    "remediation": "Use proper format string handling: errorf(\"parsing error: %v\", err)",
    "exploitation": "Error messages from user input could trigger format string vulnerabilities"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 166,
    "category": "injection",
    "type": "Format String Vulnerability",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-134",
    "description": "The errorf function is called with user-controlled input that could contain format string specifiers",
    "code_snippet": "errorf(\"%s\", err)",
    "remediation": "Use proper format string handling: errorf(\"float parsing error: %v\", err)",
    "exploitation": "Error messages from ParseFloat could contain format specifiers if input is malformed"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 190,
    "category": "injection",
    "type": "Format String Vulnerability",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-134",
    "description": "The errorf function is called with user-controlled input that could contain format string specifiers",
    "code_snippet": "errorf(\"encode: unknown type for %T\", v)",
    "remediation": "This usage is actually safe as %T is controlled by Go runtime, but consider using structured logging",
    "exploitation": "Low risk as %T is controlled by Go type system"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 204,
    "category": "injection",
    "type": "Format String Vulnerability",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-134",
    "description": "The errorf function uses format string with integer that could be manipulated",
    "code_snippet": "errorf(\"don't know how to decode binary parameter of type %d\", uint32(typ))",
    "remediation": "This is relatively safe as %d with uint32 is controlled, but use structured logging: errorf(\"unknown binary parameter type: %v\", typ)",
    "exploitation": "Lower risk as typ is an OID enum, but format string practices should be consistent"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 245,
    "category": "injection",
    "type": "Format String Vulnerability",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-134",
    "description": "The errorf function is called with user-controlled input that could contain format string specifiers",
    "code_snippet": "errorf(\"encode: unknown type for %T\", v)",
    "remediation": "This usage is safe as %T is controlled by Go runtime, but consider structured logging",
    "exploitation": "Low risk as %T is controlled by Go type system"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 339,
    "category": "injection",
    "type": "Format String Vulnerability",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-134",
    "description": "The errorf function is called with user-controlled input that could contain format string specifiers",
    "code_snippet": "errorf(\"decode: %s\", err)",
    "remediation": "Use proper format string handling: errorf(\"timestamp decode error: %v\", err)",
    "exploitation": "Error messages from time.Parse could contain format specifiers"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 376,
    "category": "validation",
    "type": "Improper Error Handling",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-754",
    "description": "Multiple validation functions set error state but continue processing instead of failing fast",
    "code_snippet": "if p.err != nil {\n\t\treturn 0\n\t}",
    "remediation": "Consider failing fast on first error rather than continuing processing with error state",
    "exploitation": "Could lead to inconsistent state or unexpected behavior when parsing malformed timestamps"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 573,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Detailed error messages may expose internal system information",
    "code_snippet": "return time.Time{}, fmt.Errorf(\"expected '-' or '+' at position %v; got %v\", tzStart, c)",
    "remediation": "Consider sanitizing error messages to avoid exposing parsing details: return time.Time{}, errors.New(\"invalid timezone format\")",
    "exploitation": "Error messages could reveal information about internal parsing logic and data formats"
  },
  {
    "file": "starttls/psql/encode.go",
    "line": 596,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Detailed error messages may expose internal system information",
    "code_snippet": "return time.Time{}, fmt.Errorf(\"expected end of input, got %v\", str[remainderIdx:])",
    "remediation": "Consider sanitizing error messages: return time.Time{}, errors.New(\"invalid timestamp format\")",
    "exploitation": "Error messages could reveal parts of the input data being processed"
  },
  {
    "file": "starttls/psql/buf.go",
    "line": 35,
    "category": "validation",
    "type": "Buffer Over-read",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-125",
    "description": "The string() method calls errorf() but continues execution, potentially reading beyond buffer bounds",
    "code_snippet": "func (b *readBuf) string() string {\n\ti := bytes.IndexByte(*b, 0)\n\tif i < 0 {\n\t\terrorf(\"invalid message format; expected string terminator\")\n\t}\n\ts := (*b)[:i]\n\t*b = (*b)[i+1:]\n\treturn string(s)\n}",
    "remediation": "Return an error or panic instead of continuing execution:\nif i < 0 {\n\tpanic(\"invalid message format; expected string terminator\")\n}\n// OR return error:\nif i < 0 {\n\treturn \"\", errors.New(\"invalid message format\")\n}",
    "exploitation": "Attacker can send malformed PostgreSQL messages without null terminators, causing buffer over-read and potential memory disclosure"
  },
  {
    "file": "starttls/psql/buf.go",
    "line": 42,
    "category": "validation",
    "type": "Buffer Over-read",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-125",
    "description": "The next() method doesn't validate that requested bytes are available in buffer",
    "code_snippet": "func (b *readBuf) next(n int) (v []byte) {\n\tv = (*b)[:n]\n\t*b = (*b)[n:]\n\treturn\n}",
    "remediation": "Add bounds checking:\nfunc (b *readBuf) next(n int) (v []byte) {\n\tif len(*b) < n {\n\t\tpanic(\"buffer underflow: requested more bytes than available\")\n\t}\n\tv = (*b)[:n]\n\t*b = (*b)[n:]\n\treturn\n}",
    "exploitation": "Attacker can request more bytes than available, causing slice bounds panic or reading beyond allocated memory"
  },
  {
    "file": "starttls/psql/buf.go",
    "line": 12,
    "category": "validation",
    "type": "Buffer Over-read",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-125",
    "description": "The int32() method doesn't validate buffer has at least 4 bytes before reading",
    "code_snippet": "func (b *readBuf) int32() (n int) {\n\tn = int(int32(binary.BigEndian.Uint32(*b)))\n\t*b = (*b)[4:]\n\treturn\n}",
    "remediation": "Add bounds checking:\nfunc (b *readBuf) int32() (n int) {\n\tif len(*b) < 4 {\n\t\tpanic(\"buffer underflow: not enough bytes for int32\")\n\t}\n\tn = int(int32(binary.BigEndian.Uint32(*b)))\n\t*b = (*b)[4:]\n\treturn\n}",
    "exploitation": "Attacker can send truncated messages causing panic or memory access violations when trying to read 4-byte integer"
  },
  {
    "file": "starttls/psql/buf.go",
    "line": 18,
    "category": "validation",
    "type": "Buffer Over-read",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-125",
    "description": "The oid() method doesn't validate buffer has at least 4 bytes before reading",
    "code_snippet": "func (b *readBuf) oid() (n oid.Oid) {\n\tn = oid.Oid(binary.BigEndian.Uint32(*b))\n\t*b = (*b)[4:]\n\treturn\n}",
    "remediation": "Add bounds checking:\nfunc (b *readBuf) oid() (n oid.Oid) {\n\tif len(*b) < 4 {\n\t\tpanic(\"buffer underflow: not enough bytes for oid\")\n\t}\n\tn = oid.Oid(binary.BigEndian.Uint32(*b))\n\t*b = (*b)[4:]\n\treturn\n}",
    "exploitation": "Attacker can send malformed PostgreSQL protocol messages causing buffer over-read when parsing OID fields"
  },
  {
    "file": "starttls/psql/buf.go",
    "line": 25,
    "category": "validation",
    "type": "Buffer Over-read",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-125",
    "description": "The int16() method doesn't validate buffer has at least 2 bytes before reading",
    "code_snippet": "func (b *readBuf) int16() (n int) {\n\tn = int(binary.BigEndian.Uint16(*b))\n\t*b = (*b)[2:]\n\treturn\n}",
    "remediation": "Add bounds checking:\nfunc (b *readBuf) int16() (n int) {\n\tif len(*b) < 2 {\n\t\tpanic(\"buffer underflow: not enough bytes for int16\")\n\t}\n\tn = int(binary.BigEndian.Uint16(*b))\n\t*b = (*b)[2:]\n\treturn\n}",
    "exploitation": "Attacker can send truncated PostgreSQL messages causing panic when trying to read 2-byte integer fields"
  },
  {
    "file": "starttls/psql/buf.go",
    "line": 47,
    "category": "validation",
    "type": "Buffer Over-read",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-125",
    "description": "The byte() method calls next(1) without validating buffer bounds",
    "code_snippet": "func (b *readBuf) byte() byte {\n\treturn b.next(1)[0]\n}",
    "remediation": "Add explicit bounds check or rely on next() bounds checking:\nfunc (b *readBuf) byte() byte {\n\tif len(*b) < 1 {\n\t\tpanic(\"buffer underflow: no bytes available\")\n\t}\n\treturn b.next(1)[0]\n}",
    "exploitation": "Combined with the next() method vulnerability, this can cause buffer over-read when parsing single-byte fields"
  },
  {
    "file": "starttls/psql/error.go",
    "line": 351,
    "category": "exposure",
    "type": "Sensitive Data in Logs",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-532",
    "description": "Error message directly exposes internal database error details to clients without sanitization",
    "code_snippet": "func (err Error) Error() string {\n\treturn \"pq: \" + err.Message\n}",
    "remediation": "Sanitize error messages before returning to clients:\n\nfunc (err Error) Error() string {\n\tif err.Fatal() || err.Code.Class() == \"28\" { // Auth errors\n\t\treturn \"pq: database error\"\n\t}\n\treturn \"pq: \" + sanitizeErrorMessage(err.Message)\n}",
    "exploitation": "Attackers can extract database schema information, table names, and internal system details from error messages"
  },
  {
    "file": "starttls/psql/error.go",
    "line": 410,
    "category": "exposure",
    "type": "Information Leakage",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Error recovery function exposes detailed internal error information including system paths and technical details",
    "code_snippet": "if v == io.EOF || v.(error).Error() == \"remote error: handshake failure\" {\n\t*err = driver.ErrBadConn\n} else {\n\t*err = v\n}",
    "remediation": "Replace detailed errors with generic messages:\n\nif v == io.EOF || strings.Contains(v.Error(), \"handshake failure\") {\n\t*err = driver.ErrBadConn\n} else {\n\t*err = errors.New(\"database connection error\")\n}",
    "exploitation": "Internal error details can reveal system architecture, file paths, and configuration information"
  },
  {
    "file": "starttls/psql/error.go",
    "line": 417,
    "category": "exposure",
    "type": "Error Details",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Panic with detailed error information could expose internal system details in stack traces",
    "code_snippet": "default:\n\tc.bad = true\n\tpanic(fmt.Sprintf(\"unknown error: %#v\", e))",
    "remediation": "Use generic error messages in production:\n\ndefault:\n\tc.bad = true\n\tlog.Printf(\"Internal error: %#v\", e) // Log internally only\n\tpanic(\"internal database error\")",
    "exploitation": "Stack traces from panics can reveal internal code structure and system information"
  },
  {
    "file": "starttls/psql/error.go",
    "line": 282,
    "category": "exposure",
    "type": "Sensitive Data in Logs",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-532",
    "description": "PostgreSQL error parsing exposes all database error details including potentially sensitive information from queries, schema, and constraints",
    "code_snippet": "func parseError(r *readBuf) *Error {\n\terr := new(Error)\n\tfor t := r.byte(); t != 0; t = r.byte() {\n\t\tmsg := r.string()\n\t\tswitch t {\n\t\t// ... all error details are preserved",
    "remediation": "Filter sensitive error details before exposing:\n\nfunc parseError(r *readBuf) *Error {\n\terr := new(Error)\n\tfor t := r.byte(); t != 0; t = r.byte() {\n\t\tmsg := r.string()\n\t\tswitch t {\n\t\tcase 'S': err.Severity = msg\n\t\tcase 'C': err.Code = ErrorCode(msg)\n\t\tcase 'M': err.Message = sanitizeMessage(msg)\n\t\t// Filter out sensitive fields like 'F', 'L', 'R', 'q'\n\t\t}\n\t}\n\treturn err\n}",
    "exploitation": "Database errors can leak schema information, table structures, constraint names, file paths, and query details that help attackers understand the database structure"
  },
  {
    "file": "starttls/psql/user_posix.go",
    "line": 17,
    "category": "injection",
    "type": "Environment Variable Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "Username retrieved from USER environment variable without validation, potentially allowing injection attacks if used in security contexts",
    "code_snippet": "name := os.Getenv(\"USER\")\n\tif name != \"\" {\n\t\treturn name, nil\n\t}",
    "remediation": "Validate the username from environment variable: if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_.-]+$`, name); !matched { return \"\", ErrInvalidUsername }",
    "exploitation": "Attacker could set USER environment variable to malicious value containing special characters, potentially leading to injection if username is used in shell commands, SQL queries, or file paths"
  },
  {
    "file": "starttls/psql/user_posix.go",
    "line": 13,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Function returns system username which may leak sensitive information about the system or user context",
    "code_snippet": "u, err := user.Current()\n\tif err == nil {\n\t\treturn u.Username, nil\n\t}",
    "remediation": "Consider whether exposing system usernames is necessary. If username is only needed for database connection defaults, validate and sanitize before use",
    "exploitation": "Username disclosure could aid attackers in reconnaissance, revealing system account names or organizational naming conventions"
  },
  {
    "file": "starttls/psql/user_windows.go",
    "line": 15,
    "category": "validation",
    "type": "Buffer Overflow Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-120",
    "description": "Fixed-size buffer (128 uint16) for username lookup without validation of actual username length from system",
    "code_snippet": "pw_name := make([]uint16, 128)\npwname_size := uint32(len(pw_name)) - 1",
    "remediation": "Use dynamic buffer sizing or check return codes to handle cases where username exceeds buffer size: if err == syscall.ERROR_MORE_DATA { // resize buffer and retry }",
    "exploitation": "If system username exceeds 127 UTF-16 characters, function may fail silently or truncate username, potentially causing authentication issues"
  },
  {
    "file": "starttls/psql/user_windows.go",
    "line": 21,
    "category": "validation",
    "type": "Unchecked Array Bounds",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-129",
    "description": "syscall.UTF16ToString is called on pw_name buffer without verifying the pwname_size return value indicates valid data length",
    "code_snippet": "s := syscall.UTF16ToString(pw_name)",
    "remediation": "Validate pwname_size after syscall and slice buffer accordingly: s := syscall.UTF16ToString(pw_name[:pwname_size+1])",
    "exploitation": "Could potentially read uninitialized memory if syscall doesn't properly null-terminate the buffer"
  },
  {
    "file": "starttls/psql/user_windows.go",
    "line": 22,
    "category": "validation",
    "type": "Path Manipulation",
    "severity": "low",
    "confidence": "low",
    "cwe": "CWE-22",
    "description": "filepath.Base() is used to extract username component, but no validation that the result is a valid username format",
    "code_snippet": "u := filepath.Base(s)",
    "remediation": "Add validation that the extracted username matches expected format: if !regexp.MustCompile(`^[a-zA-Z0-9._-]+$`).MatchString(u) { return \"\", ErrInvalidUsername }",
    "exploitation": "Malformed system responses could potentially return unexpected characters that might cause issues in downstream username handling"
  },
  {
    "file": "starttls/psql/notify.go",
    "line": 109,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-89",
    "description": "User-controlled channel name is directly concatenated into SQL LISTEN command without proper validation",
    "code_snippet": "return l.ExecSimpleQuery(\"LISTEN \" + QuoteIdentifier(channel))",
    "remediation": "While QuoteIdentifier() provides some protection, validate channel names against a strict allowlist: if !regexp.MustMatch(`^[a-zA-Z_][a-zA-Z0-9_]*$`, channel) { return false, errors.New(\"invalid channel name\") }",
    "exploitation": "Attacker could potentially bypass QuoteIdentifier() protection with specially crafted channel names to inject SQL commands"
  },
  {
    "file": "starttls/psql/notify.go",
    "line": 114,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-89",
    "description": "User-controlled channel name in UNLISTEN command relies only on QuoteIdentifier() for protection",
    "code_snippet": "return l.ExecSimpleQuery(\"UNLISTEN \" + QuoteIdentifier(channel))",
    "remediation": "Add input validation before QuoteIdentifier(): if !regexp.MustMatch(`^[a-zA-Z_][a-zA-Z0-9_]*$`, channel) { return false, errors.New(\"invalid channel name\") }",
    "exploitation": "Similar to LISTEN, potential SQL injection if QuoteIdentifier() protection is insufficient"
  },
  {
    "file": "starttls/psql/notify.go",
    "line": 341,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-89",
    "description": "Arbitrary query string passed to ExecSimpleQuery without validation",
    "code_snippet": "func (l *ListenerConn) ExecSimpleQuery(q string) (executed bool, err error)",
    "remediation": "Add query validation or use a safe query builder. For internal use, consider restricting to predefined query patterns: allowedQueries := map[string]bool{\"LISTEN %s\": true, \"UNLISTEN %s\": true}",
    "exploitation": "If ExecSimpleQuery is exposed to user input elsewhere, could allow arbitrary SQL execution"
  },
  {
    "file": "starttls/psql/notify.go",
    "line": 127,
    "category": "validation",
    "type": "Input Validation",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-20",
    "description": "Empty string passed to Ping() is sent as SQL query without validation",
    "code_snippet": "sent, err := l.ExecSimpleQuery(\"\")",
    "remediation": "Use a safe ping query: sent, err := l.ExecSimpleQuery(\"SELECT 1\")",
    "exploitation": "Empty query might cause unexpected database behavior or reveal information through error messages"
  },
  {
    "file": "starttls/psql/notify.go",
    "line": 589,
    "category": "validation",
    "type": "Race Condition",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-362",
    "description": "Channel existence check and subsequent operations not atomic, allowing race condition",
    "code_snippet": "_, exists := l.channels[channel]\nif exists {\n    return ErrChannelAlreadyOpen\n}\n// ... gap where state can change ...\nl.channels[channel] = struct{}{}",
    "remediation": "Perform atomic check-and-set operation or use proper synchronization to prevent race conditions",
    "exploitation": "Concurrent Listen() calls on same channel could bypass duplicate detection"
  },
  {
    "file": "starttls/psql/notify.go",
    "line": 750,
    "category": "validation",
    "type": "Resource Exhaustion",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-400",
    "description": "Notification channels created with fixed buffer size without limits on number of channels",
    "code_snippet": "notificationChan := make(chan *Notification, 32)",
    "remediation": "Add limits on total number of listening channels: const maxChannels = 100; if len(l.channels) >= maxChannels { return errors.New(\"too many channels\") }",
    "exploitation": "Attacker could create many listening channels to consume memory resources"
  },
  {
    "file": "starttls/psql/copy.go",
    "line": 161,
    "category": "exposure",
    "type": "Error Information Disclosure",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Error details are sent to the database server in CopyFail message, potentially exposing sensitive information about the application's internal state",
    "code_snippet": "b.string(err.Error())",
    "remediation": "Send a generic error message to the server instead of the full error details: b.string(\"COPY operation failed\")",
    "exploitation": "Database logs or monitoring systems could capture detailed error information that reveals internal application structure, file paths, or other sensitive data"
  },
  {
    "file": "starttls/psql/doc.go",
    "line": 26,
    "category": "config",
    "type": "Insecure Default SSL Mode",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-319",
    "description": "Documentation states that default sslmode is 'require' which skips certificate verification, unlike libpq's default",
    "code_snippet": "sslmode - Whether or not to use SSL (default is require, this is not the default for libpq)",
    "remediation": "Use 'verify-full' for production connections: \"postgres://user:pass@host/db?sslmode=verify-full\"",
    "exploitation": "Man-in-the-middle attacks possible when certificate verification is skipped"
  },
  {
    "file": "starttls/psql/doc.go",
    "line": 14,
    "category": "exposure",
    "type": "Hardcoded Password in Example",
    "severity": "low",
    "confidence": "low",
    "cwe": "CWE-798",
    "description": "Documentation example contains a hardcoded password, which may be copied by developers",
    "code_snippet": "db, err := sql.Open(\"postgres\", \"postgres://pqgotest:password@localhost/pqgotest?sslmode=verify-full\")",
    "remediation": "Use environment variables or configuration files: \"postgres://user:\" + os.Getenv(\"DB_PASSWORD\") + \"@host/db\"",
    "exploitation": "If developers copy example code with hardcoded credentials, it could lead to credential exposure"
  },
  {
    "file": "starttls/psql/url.go",
    "line": 75,
    "category": "exposure",
    "type": "Sensitive Data in Logs",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-532",
    "description": "Password from URL is processed and included in connection string without sanitization, potentially exposing credentials in logs or error messages",
    "code_snippet": "v, _ = u.User.Password()\naccrue(\"password\", v)",
    "remediation": "Avoid logging connection strings containing passwords. Consider masking sensitive parameters in debug output and ensure connection strings are not logged.",
    "exploitation": "Passwords could be exposed in application logs, error messages, or debug output"
  },
  {
    "file": "starttls/psql/url.go",
    "line": 30,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Error message exposes the exact scheme provided by user input, which could aid attackers in reconnaissance",
    "code_snippet": "return \"\", fmt.Errorf(\"invalid connection protocol: %s\", u.Scheme)",
    "remediation": "Use generic error message: return \"\", fmt.Errorf(\"invalid connection protocol\")",
    "exploitation": "Attackers can probe different schemes to understand application behavior and valid input formats"
  },
  {
    "file": "starttls/psql/url.go",
    "line": 88,
    "category": "validation",
    "type": "Injection via Query Parameters",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "URL query parameters are directly passed through to connection string without validation, potentially allowing injection of unexpected connection parameters",
    "code_snippet": "q := u.Query()\nfor k := range q {\n\taccrue(k, q.Get(k))\n}",
    "remediation": "Validate query parameter names against an allowlist of known PostgreSQL connection parameters: allowedParams := map[string]bool{\"sslmode\": true, \"connect_timeout\": true, ...}; if !allowedParams[k] { continue }",
    "exploitation": "Attackers could inject unexpected connection parameters that might affect database behavior or expose information"
  },
  {
    "file": "starttls/psql/url.go",
    "line": 34,
    "category": "validation",
    "type": "Insufficient Input Validation",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "No validation of URL components beyond scheme checking, allowing potentially malicious hostnames, paths, or parameter values",
    "code_snippet": "if u.Scheme != \"postgres\" && u.Scheme != \"postgresql\" {\n\treturn \"\", fmt.Errorf(\"invalid connection protocol: %s\", u.Scheme)\n}",
    "remediation": "Add validation for hostname format, port ranges, and database name format. Example: if net.ParseIP(host) == nil && !isValidHostname(host) { return \"\", fmt.Errorf(\"invalid hostname\") }",
    "exploitation": "Malformed URLs could cause unexpected behavior or be used in social engineering attacks"
  },
  {
    "file": "starttls/psql/ssl_go1.7.go",
    "line": 11,
    "category": "crypto",
    "type": "Insecure TLS Configuration",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "TLS renegotiation is explicitly enabled which creates security vulnerabilities. TLS renegotiation can lead to man-in-the-middle attacks and denial of service conditions.",
    "code_snippet": "conf.Renegotiation = tls.RenegotiateFreelyAsClient",
    "remediation": "Disable TLS renegotiation or use RenegotiateOnceAsClient if backward compatibility is absolutely required: conf.Renegotiation = tls.RenegotiateNever",
    "exploitation": "Attackers can exploit TLS renegotiation to perform prefix injection attacks, intercept sensitive data, or cause denial of service through excessive renegotiation requests"
  },
  {
    "file": "starttls/psql/conn_go18.go",
    "line": 12,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "critical",
    "confidence": "high",
    "cwe": "CWE-89",
    "description": "Raw SQL query string passed directly to cn.query() without proper validation or sanitization",
    "code_snippet": "r, err := cn.query(query, list)",
    "remediation": "Ensure the underlying cn.query() method properly uses parameterized queries and validates the query string against a whitelist of allowed operations",
    "exploitation": "Attacker can inject malicious SQL if the query parameter contains unsanitized user input"
  },
  {
    "file": "starttls/psql/conn_go18.go",
    "line": 30,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "critical",
    "confidence": "high",
    "cwe": "CWE-89",
    "description": "Raw SQL query string passed directly to cn.Exec() without proper validation or sanitization",
    "code_snippet": "return cn.Exec(query, list)",
    "remediation": "Ensure the underlying cn.Exec() method properly uses parameterized queries and validates the query string against a whitelist of allowed operations",
    "exploitation": "Attacker can inject malicious SQL if the query parameter contains unsanitized user input"
  },
  {
    "file": "starttls/psql/conn_go18.go",
    "line": 72,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Connection cancellation function may leak sensitive connection details through error handling",
    "code_snippet": "defer can.errRecover(&err)",
    "remediation": "Ensure errRecover() method sanitizes error messages and doesn't expose internal connection details like hostnames, ports, or credentials",
    "exploitation": "Error messages could reveal internal network topology or connection parameters to attackers"
  },
  {
    "file": "starttls/psql/conn_go18.go",
    "line": 74,
    "category": "exposure",
    "type": "Sensitive Data Exposure",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-200",
    "description": "Process ID and secret key transmitted over network connection during cancellation",
    "code_snippet": "w.int32(cn.processID)\n\tw.int32(cn.secretKey)",
    "remediation": "Ensure these values are transmitted over an encrypted connection and implement proper authentication for cancel requests",
    "exploitation": "If transmitted over unencrypted connection, attackers could intercept and potentially abuse process credentials"
  },
  {
    "file": "starttls/psql/conn_go18.go",
    "line": 57,
    "category": "config",
    "type": "Resource Leak",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-404",
    "description": "Goroutine created in watchCancel may not be properly cleaned up in all scenarios",
    "code_snippet": "go func() {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\tcancel()\n\t\tcase <-closed:\n\t\t}\n\t}()",
    "remediation": "Consider using a sync.Once or similar mechanism to ensure the goroutine terminates properly and doesn't leak resources",
    "exploitation": "Under high load, goroutine leaks could lead to resource exhaustion and denial of service"
  },
  {
    "file": "starttls/psql/ssl_windows.go",
    "line": 8,
    "category": "crypto",
    "type": "Missing Certificate Permission Check",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-732",
    "description": "Certificate and private key file permissions are not validated on Windows, which could allow unauthorized access to cryptographic materials if files have overly permissive access controls",
    "code_snippet": "func sslCertificatePermissions(cert, key os.FileInfo) {}",
    "remediation": "Implement proper permission checks for Windows using GetNamedSecurityInfo() and VerifyAcl() to ensure certificate files are readable only by the owner and system, similar to the Unix 0600 permission model",
    "exploitation": "If certificate or private key files have world-readable permissions, attackers with local access could steal cryptographic materials and impersonate the application or decrypt TLS traffic"
  },
  {
    "file": "starttls/psql/uuid.go",
    "line": 17,
    "category": "validation",
    "type": "Buffer Overflow",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-787",
    "description": "Fixed-size destination buffer slice operations could potentially write beyond intended boundaries due to hex.Encode behavior",
    "code_snippet": "hex.Encode(dst[0:], src[0:4])\nhex.Encode(dst[9:], src[4:6])\nhex.Encode(dst[14:], src[6:8])\nhex.Encode(dst[19:], src[8:10])\nhex.Encode(dst[24:], src[10:16])",
    "remediation": "Use hex.Encode with explicit length-bounded slices:\nhex.Encode(dst[0:8], src[0:4])\nhex.Encode(dst[9:13], src[4:6])\nhex.Encode(dst[14:18], src[6:8])\nhex.Encode(dst[19:23], src[8:10])\nhex.Encode(dst[24:36], src[10:16])",
    "exploitation": "While Go's memory safety makes this less critical, unbounded slice operations could theoretically cause memory corruption in edge cases"
  },
  {
    "file": "starttls/psql/uuid.go",
    "line": 9,
    "category": "validation",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Error message reveals internal buffer length which could aid attackers in understanding data structure",
    "code_snippet": "return nil, fmt.Errorf(\"pq: unable to decode uuid; bad length: %d\", len(src))",
    "remediation": "Use generic error message without revealing internal details:\nreturn nil, fmt.Errorf(\"pq: invalid uuid format\")",
    "exploitation": "Attacker could use length information to craft more targeted attacks or understand internal data handling"
  },
  {
    "file": "starttls/psql/array.go",
    "line": 312,
    "category": "validation",
    "type": "Input Validation Bypass",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "The parseArray function processes user-controlled array data from database without sufficient bounds checking on array dimensions",
    "code_snippet": "dims = make([]int, i)",
    "remediation": "Add maximum dimension limits: if i > MAX_ARRAY_DIMENSIONS { return nil, nil, fmt.Errorf(\"array dimensions exceed limit\") }",
    "exploitation": "Attacker could send malformed array data with excessive dimensions to cause memory exhaustion"
  },
  {
    "file": "starttls/psql/array.go",
    "line": 334,
    "category": "validation",
    "type": "Buffer Over-allocation",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-770",
    "description": "The elems slice is allocated without bounds checking on potential size, allowing memory exhaustion attacks",
    "code_snippet": "elems = make([][]byte, 0)",
    "remediation": "Add maximum element count validation: const MAX_ELEMENTS = 100000; if estimatedElements > MAX_ELEMENTS { return error }",
    "exploitation": "Malicious array data could cause the application to allocate excessive memory leading to DoS"
  },
  {
    "file": "starttls/psql/array.go",
    "line": 280,
    "category": "validation",
    "type": "Unbounded Memory Allocation",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-770",
    "description": "The appendArray function allocates buffer space based on user-controlled array size without limits",
    "code_snippet": "b := make([]byte, 0, 1+2*n)",
    "remediation": "Add size validation: if n > MAX_ARRAY_SIZE { return nil, \"\", fmt.Errorf(\"array too large\") }",
    "exploitation": "Large arrays from database could cause excessive memory allocation"
  },
  {
    "file": "starttls/psql/array.go",
    "line": 368,
    "category": "validation",
    "type": "Infinite Loop Potential",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-835",
    "description": "The quoted string parsing loop could potentially run indefinitely with malformed input",
    "code_snippet": "for i++; i < len(src); i++ { if escape { elem = append(elem, src[i]) escape = false } else { switch src[i] { ... } } }",
    "remediation": "Add iteration counter and maximum string length check to prevent infinite loops and excessive memory usage",
    "exploitation": "Specially crafted array strings could cause infinite loops leading to DoS"
  },
  {
    "file": "starttls/psql/array.go",
    "line": 445,
    "category": "validation",
    "type": "Resource Exhaustion",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-400",
    "description": "The appendArrayQuotedBytes function processes byte arrays without size limits, potentially causing resource exhaustion",
    "code_snippet": "for { i := bytes.IndexAny(v, `\"\\`) if i < 0 { b = append(b, v...) break } ... }",
    "remediation": "Add maximum byte array size check: if len(v) > MAX_BYTES { return nil, fmt.Errorf(\"byte array too large\") }",
    "exploitation": "Large byte arrays could consume excessive memory and CPU during escaping"
  },
  {
    "file": "starttls/psql/ssl.go",
    "line": 19,
    "category": "crypto",
    "type": "Insecure TLS Configuration",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-295",
    "description": "TLS certificate verification is disabled by setting InsecureSkipVerify to true in 'require' mode, making connections vulnerable to man-in-the-middle attacks",
    "code_snippet": "tlsConf.InsecureSkipVerify = true",
    "remediation": "Remove InsecureSkipVerify = true and implement proper certificate validation. Use 'verify-ca' or 'verify-full' modes for production deployments",
    "exploitation": "Attacker can intercept TLS connections and present their own certificate without detection, allowing them to decrypt and modify data in transit"
  },
  {
    "file": "starttls/psql/ssl.go",
    "line": 33,
    "category": "crypto",
    "type": "Insecure TLS Configuration",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-295",
    "description": "TLS certificate verification is disabled by setting InsecureSkipVerify to true in 'verify-ca' mode, undermining the security intent of this mode",
    "code_snippet": "tlsConf.InsecureSkipVerify = true",
    "remediation": "Implement proper certificate authority validation without disabling TLS verification. Use Go's built-in certificate validation with custom verification logic if needed",
    "exploitation": "Even in verify-ca mode, connections remain vulnerable to man-in-the-middle attacks due to disabled certificate verification"
  },
  {
    "file": "starttls/psql/ssl.go",
    "line": 76,
    "category": "validation",
    "type": "Path Traversal",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-22",
    "description": "User-controlled sslcert and sslkey parameters are used directly in file operations without path validation",
    "code_snippet": "cinfo, err = os.Stat(sslcert)\nkinfo, err = os.Stat(sslkey)",
    "remediation": "Validate certificate paths to ensure they are within allowed directories: filepath.Clean(sslcert); if !strings.HasPrefix(filepath.Clean(sslcert), allowedDir) { return error }",
    "exploitation": "Attacker could specify paths like '../../../etc/passwd' to access files outside intended certificate directories"
  },
  {
    "file": "starttls/psql/ssl.go",
    "line": 99,
    "category": "validation",
    "type": "Path Traversal",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-22",
    "description": "User-controlled sslrootcert parameter is used directly in file operations without path validation",
    "code_snippet": "cert, err := os.ReadFile(sslrootcert)",
    "remediation": "Validate the root certificate path before reading: sslrootcert = filepath.Clean(sslrootcert); validate it's within allowed directories",
    "exploitation": "Attacker could read arbitrary files from the filesystem by manipulating the sslrootcert parameter"
  },
  {
    "file": "starttls/psql/ssl.go",
    "line": 67,
    "category": "config",
    "type": "Error Handling Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "File system errors are exposed through panic() which may reveal sensitive path information",
    "code_snippet": "if err != nil {\n\tpanic(err)\n}",
    "remediation": "Handle errors gracefully without exposing internal details: if err != nil { return fmt.Errorf(\"certificate file error\") }",
    "exploitation": "Error messages may reveal internal file system structure or certificate locations to attackers"
  },
  {
    "file": "starttls/psql/oid/gen.go",
    "line": 27,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-89",
    "description": "Empty connection string passed to sql.Open allows environment variables to control database connection parameters without validation",
    "code_snippet": "db, err := sql.Open(\"postgres\", \"\")",
    "remediation": "Validate environment variables and construct connection string explicitly: connStr := fmt.Sprintf(\"dbname=%s sslmode=%s\", datname, sslmode); db, err := sql.Open(\"postgres\", connStr)",
    "exploitation": "Attacker who can control environment variables could potentially connect to unintended databases or modify connection parameters"
  },
  {
    "file": "starttls/psql/conn.go",
    "line": 899,
    "category": "crypto",
    "type": "Weak Hash Algorithm - MD5",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "MD5 hash algorithm is used for password authentication, which is cryptographically broken and vulnerable to collision attacks",
    "code_snippet": "w.string(\"md5\" + md5s(md5s(o.Get(\"password\")+o.Get(\"user\"))+s))",
    "remediation": "Use stronger hash algorithms like SHA-256 or bcrypt. However, this appears to be implementing PostgreSQL's MD5 authentication protocol, so consider using stronger authentication methods like SCRAM-SHA-256 if supported by the server.",
    "exploitation": "Attackers with captured authentication hashes could potentially perform offline brute force attacks or exploit MD5 collision vulnerabilities"
  },
  {
    "file": "starttls/psql/conn.go",
    "line": 1652,
    "category": "crypto",
    "type": "Weak Hash Algorithm - MD5",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "MD5 hash function is used in the md5s utility function, supporting the weak authentication mechanism",
    "code_snippet": "func md5s(s string) string {\n\th := md5.New()\n\th.Write([]byte(s))\n\treturn fmt.Sprintf(\"%x\", h.Sum(nil))\n}",
    "remediation": "Replace MD5 with SHA-256 or stronger algorithms: import \"crypto/sha256\"; h := sha256.New()",
    "exploitation": "MD5 is vulnerable to collision attacks and pre-image attacks, making password verification potentially bypassable"
  },
  {
    "file": "starttls/psql/conn.go",
    "line": 169,
    "category": "exposure",
    "type": "Sensitive Data in Logs",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-532",
    "description": "Password may be included in pgpass file processing and could be logged or exposed in error messages",
    "code_snippet": "o[\"password\"] = split[4]",
    "remediation": "Ensure passwords are not logged and implement secure credential handling with proper memory clearing after use",
    "exploitation": "Passwords could be exposed in application logs or debug output"
  },
  {
    "file": "starttls/psql/conn.go",
    "line": 314,
    "category": "exposure",
    "type": "Information Leakage",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Detailed error messages may expose internal system information through panic statements",
    "code_snippet": "panic(fmt.Sprintf(\"setting datestyle must be absent or %v; got %v\", \"ISO, MDY\", datestyle))",
    "remediation": "Sanitize error messages before exposing to users and log detailed errors separately for debugging",
    "exploitation": "Internal configuration details could help attackers understand system architecture"
  },
  {
    "file": "starttls/psql/conn.go",
    "line": 448,
    "category": "config",
    "type": "TLS Configuration",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-295",
    "description": "TLS configuration accepts empty config which may not enforce proper certificate validation",
    "code_snippet": "func DumpTLS(name string) (_ *tls.ConnectionState, err error) {\n\treturn DumpTLSWithConfig(name, &tls.Config{})\n}",
    "remediation": "Use secure TLS configuration with proper certificate validation: &tls.Config{MinVersion: tls.VersionTLS12, InsecureSkipVerify: false}",
    "exploitation": "Man-in-the-middle attacks could be possible if certificate validation is not properly enforced"
  },
  {
    "file": "starttls/mysql/infile.go",
    "line": 104,
    "category": "validation",
    "type": "Path Traversal",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-22",
    "description": "The code allows file access based on user-controlled input without proper path validation. An attacker could use path traversal sequences (../../../etc/passwd) to access files outside the intended directory.",
    "code_snippet": "if file, err = os.Open(name); err == nil {",
    "remediation": "Implement proper path validation: 1) Resolve the absolute path using filepath.Clean() and filepath.Abs(), 2) Ensure the resolved path is within allowed directories, 3) Use filepath.Join() for safe path construction. Example: cleanPath := filepath.Clean(name); if !strings.HasPrefix(cleanPath, allowedBasePath) { return fmt.Errorf(\"path not allowed\") }",
    "exploitation": "Attacker can read arbitrary files by registering paths like '../../../etc/passwd' or using LOAD DATA LOCAL INFILE with traversal sequences"
  },
  {
    "file": "starttls/mysql/infile.go",
    "line": 98,
    "category": "config",
    "type": "Insecure Default Configuration",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-1188",
    "description": "The AllowAllFiles configuration option bypasses all file access restrictions, potentially allowing access to any file on the system if enabled.",
    "code_snippet": "if mc.cfg.AllowAllFiles || fr {",
    "remediation": "1) Document the security implications of AllowAllFiles clearly, 2) Consider implementing additional safeguards even when AllowAllFiles is true (e.g., blacklist sensitive paths like /etc/passwd, /proc/*, etc.), 3) Log file access attempts when this option is enabled for security monitoring",
    "exploitation": "If AllowAllFiles is enabled, attackers can read any file accessible to the application process"
  },
  {
    "file": "starttls/mysql/infile.go",
    "line": 75,
    "category": "validation",
    "type": "Insufficient Input Validation",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "The Reader name extraction logic uses string manipulation that could be bypassed with carefully crafted input. The check for 'Reader::' at index 0 or after '/' may not cover all attack vectors.",
    "code_snippet": "if idx := strings.Index(name, \"Reader::\"); idx == 0 || (idx > 0 && name[idx-1] == '/') {",
    "remediation": "Implement more robust parsing: 1) Use filepath.Base() to get the filename component, 2) Validate the Reader:: prefix more strictly, 3) Add length limits and character restrictions. Example: baseName := filepath.Base(name); if !strings.HasPrefix(baseName, \"Reader::\") { /* handle as file */ }",
    "exploitation": "Attacker might craft filenames that bypass the Reader:: detection and access unintended files"
  },
  {
    "file": "starttls/mysql/infile.go",
    "line": 94,
    "category": "validation",
    "type": "Insufficient Path Sanitization",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-20",
    "description": "The path sanitization only removes surrounding quotes but doesn't handle other potential bypasses like URL encoding, Unicode normalization, or symbolic links.",
    "code_snippet": "name = strings.Trim(name, `\"`)",
    "remediation": "Implement comprehensive path sanitization: 1) Use filepath.Clean() to resolve . and .. sequences, 2) Check for symbolic links with os.Lstat(), 3) Validate against allowed file extensions and paths, 4) Consider URL decoding if applicable. Example: cleanName := filepath.Clean(strings.Trim(name, `\"`)); if fi, err := os.Lstat(cleanName); err == nil && fi.Mode()&os.ModeSymlink != 0 { return fmt.Errorf(\"symbolic links not allowed\") }",
    "exploitation": "Attacker could use symbolic links or other path manipulation techniques to access restricted files"
  },
  {
    "file": "starttls/mysql/statement.go",
    "line": 25,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Error logging may expose connection details to logs when ErrInvalidConn occurs",
    "code_snippet": "//errLog.Print(ErrInvalidConn)",
    "remediation": "Consider sanitizing error messages before logging to avoid exposing internal connection details",
    "exploitation": "Attackers with access to logs could gain information about database connection states"
  },
  {
    "file": "starttls/mysql/statement.go",
    "line": 43,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Error logging prints ErrInvalidConn which may expose internal connection state information",
    "code_snippet": "errLog.Print(ErrInvalidConn)",
    "remediation": "Log a generic error message instead: errLog.Print(\"database connection error\")",
    "exploitation": "Attackers with access to logs could gain information about database connection states"
  },
  {
    "file": "starttls/mysql/statement.go",
    "line": 76,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Error logging prints ErrInvalidConn which may expose internal connection state information",
    "code_snippet": "errLog.Print(ErrInvalidConn)",
    "remediation": "Log a generic error message instead: errLog.Print(\"database connection error\")",
    "exploitation": "Attackers with access to logs could gain information about database connection states"
  },
  {
    "file": "starttls/mysql/statement.go",
    "line": 150,
    "category": "validation",
    "type": "Type Confusion",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-704",
    "description": "Type converter uses reflection without bounds checking on numeric conversions, potentially causing integer overflow",
    "code_snippet": "case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32:\n\t\treturn int64(rv.Uint()), nil",
    "remediation": "Add bounds checking: \nval := rv.Uint()\nif val > math.MaxInt64 {\n\treturn nil, fmt.Errorf(\"value too large\")\n}\nreturn int64(val), nil",
    "exploitation": "Large unsigned integer values could cause integer overflow when cast to signed int64"
  },
  {
    "file": "starttls/mysql/transaction.go",
    "line": 18,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "medium",
    "confidence": "low",
    "cwe": "CWE-89",
    "description": "Direct execution of SQL commands without parameterization, though impact is limited to COMMIT/ROLLBACK",
    "code_snippet": "err = tx.mc.exec(\"COMMIT\")",
    "remediation": "While COMMIT and ROLLBACK are static commands here, ensure the exec method properly handles SQL execution without allowing injection. Consider using prepared statements or constant definitions.",
    "exploitation": "Limited exploitation potential since commands are hardcoded, but if exec method is vulnerable, could potentially allow SQL injection"
  },
  {
    "file": "starttls/mysql/transaction.go",
    "line": 26,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "medium",
    "confidence": "low",
    "cwe": "CWE-89",
    "description": "Direct execution of SQL commands without parameterization, though impact is limited to COMMIT/ROLLBACK",
    "code_snippet": "err = tx.mc.exec(\"ROLLBACK\")",
    "remediation": "While COMMIT and ROLLBACK are static commands here, ensure the exec method properly handles SQL execution without allowing injection. Consider using prepared statements or constant definitions.",
    "exploitation": "Limited exploitation potential since commands are hardcoded, but if exec method is vulnerable, could potentially allow SQL injection"
  },
  {
    "file": "starttls/mysql/buffer.go",
    "line": 70,
    "category": "validation",
    "type": "Buffer Overflow",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-120",
    "description": "The fill() method can cause buffer overflow when need parameter is negative or extremely large, leading to potential memory corruption",
    "code_snippet": "if need > len(b.buf) {\n    newBuf := make([]byte, ((need/defaultBufSize)+1)*defaultBufSize)\n    copy(newBuf, b.buf)\n    b.buf = newBuf\n}",
    "remediation": "Add input validation: if need < 0 || need > maxAllowedSize { return errors.New(\"invalid buffer size\") }",
    "exploitation": "Attacker could provide negative or extremely large values causing integer overflow in buffer allocation or excessive memory consumption"
  },
  {
    "file": "starttls/mysql/buffer.go",
    "line": 116,
    "category": "validation",
    "type": "Integer Overflow",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-190",
    "description": "readNext() method lacks bounds checking on need parameter, could cause integer overflow when updating buffer indices",
    "code_snippet": "offset := b.idx\nb.idx += need\nb.length -= need",
    "remediation": "Add bounds checking: if need < 0 || need > b.length { return nil, errors.New(\"invalid read size\") }",
    "exploitation": "Large need values could cause integer overflow in index calculations leading to out-of-bounds access"
  },
  {
    "file": "starttls/mysql/buffer.go",
    "line": 130,
    "category": "validation",
    "type": "Memory Exhaustion",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-789",
    "description": "takeBuffer() method can allocate arbitrary amounts of memory without validation, enabling DoS attacks",
    "code_snippet": "if length < maxPacketSize {\n    b.buf = make([]byte, length)\n    return b.buf\n}\nreturn make([]byte, length)",
    "remediation": "Add maximum allocation limit: if length > maxAllowedBufferSize { return nil }",
    "exploitation": "Attacker can request extremely large buffers causing memory exhaustion and denial of service"
  },
  {
    "file": "starttls/mysql/buffer.go",
    "line": 70,
    "category": "validation",
    "type": "Resource Exhaustion",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-400",
    "description": "Buffer growth algorithm in fill() method has no upper bound, allowing unlimited memory growth",
    "code_snippet": "newBuf := make([]byte, ((need/defaultBufSize)+1)*defaultBufSize)",
    "remediation": "Implement maximum buffer size: const maxBufferSize = 16*1024*1024; if newSize > maxBufferSize { return errors.New(\"buffer too large\") }",
    "exploitation": "Repeated requests for larger buffers could consume all available memory"
  },
  {
    "file": "starttls/mysql/utils.go",
    "line": 73,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA1 is used for password authentication, which is cryptographically weak and vulnerable to collision attacks",
    "code_snippet": "crypt := sha1.New()\ncrypt.Write(password)\nstage1 := crypt.Sum(nil)",
    "remediation": "Use stronger cryptographic hash functions like SHA-256, SHA-3, or password-specific functions like bcrypt/scrypt/argon2. For MySQL compatibility, this may require protocol updates.",
    "exploitation": "Attackers could potentially exploit SHA1 weaknesses to crack password hashes or create collision attacks against the authentication mechanism"
  },
  {
    "file": "starttls/mysql/utils.go",
    "line": 130,
    "category": "crypto",
    "type": "Weak Random Number Generation",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-330",
    "description": "Custom pseudo-random number generator used for cryptographic purposes with predictable seed generation",
    "code_snippet": "func newMyRnd(seed1, seed2 uint32) *myRnd {\n\treturn &myRnd{\n\t\tseed1: seed1 % myRndMaxVal,\n\t\tseed2: seed2 % myRndMaxVal,\n\t}\n}",
    "remediation": "Replace custom PRNG with cryptographically secure random number generation using crypto/rand package: rand.Read(buf) or rand.Int(rand.Reader, max)",
    "exploitation": "Predictable random values could allow attackers to predict authentication tokens or bypass security mechanisms that rely on randomness"
  },
  {
    "file": "starttls/mysql/utils.go",
    "line": 170,
    "category": "crypto",
    "type": "Weak Cryptographic Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Implementation of insecure pre-4.1 MySQL password hashing algorithm with weak cryptographic properties",
    "code_snippet": "func pwHash(password []byte) (result [2]uint32) {\n\tvar add uint32 = 7\n\tvar tmp uint32\n\n\tresult[0] = 1345345333\n\tresult[1] = 0x12345671",
    "remediation": "Deprecate support for pre-4.1 MySQL authentication entirely, or clearly document security risks. Use only modern MySQL authentication methods.",
    "exploitation": "The pre-4.1 password hashing algorithm is extremely weak and can be easily broken, allowing attackers to recover plaintext passwords"
  },
  {
    "file": "starttls/mysql/utils.go",
    "line": 200,
    "category": "crypto",
    "type": "Insecure Legacy Authentication",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Implementation supports insecure pre-4.1 MySQL password scrambling which provides minimal security",
    "code_snippet": "func scrambleOldPassword(scramble, password []byte) []byte {\n\tif len(password) == 0 {\n\t\treturn nil\n\t}\n\n\tscramble = scramble[:8]",
    "remediation": "Remove support for old password authentication entirely. Add configuration option to explicitly disable legacy authentication methods with clear security warnings.",
    "exploitation": "Legacy password scrambling can be easily broken by attackers, compromising user credentials and database access"
  },
  {
    "file": "starttls/mysql/utils.go",
    "line": 350,
    "category": "validation",
    "type": "Insufficient Input Validation",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "Date/time parsing accepts potentially malformed input without strict validation",
    "code_snippet": "func parseDateTime(str string, loc *time.Location) (t time.Time, err error) {\n\tbase := \"0000-00-00 00:00:00.0000000\"\n\tswitch len(str) {\n\tcase 10, 19, 21, 22, 23, 24, 25, 26:",
    "remediation": "Add strict input validation for date/time strings. Validate format and ranges before parsing: if !regexp.MatchString(`^\\d{4}-\\d{2}-\\d{2}`, str) { return error }",
    "exploitation": "Malformed date/time input could potentially cause parsing errors or unexpected behavior in date handling logic"
  },
  {
    "file": "starttls/mysql/connection.go",
    "line": 39,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "critical",
    "confidence": "high",
    "cwe": "CWE-89",
    "description": "User input from configuration parameters is directly concatenated into SQL SET statements without sanitization",
    "code_snippet": "err = mc.exec(\"SET \" + param + \"=\" + val + \"\")",
    "remediation": "Use parameterized queries or validate/sanitize parameter names and values: if isValidParam(param) && isValidValue(val) { err = mc.exec(fmt.Sprintf(\"SET `%s`=?\", param), val) }",
    "exploitation": "Attacker can inject malicious SQL through DSN parameters to execute arbitrary database commands"
  },
  {
    "file": "starttls/mysql/connection.go",
    "line": 32,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "high",
    "confidence": "medium",
    "cwe": "CWE-89",
    "description": "Charset parameter is directly concatenated into SET NAMES SQL statement without validation",
    "code_snippet": "err = mc.exec(\"SET NAMES \" + charsets[i])",
    "remediation": "Validate charset against allowed values: allowedCharsets := map[string]bool{\"utf8\": true, \"utf8mb4\": true}; if allowedCharsets[charset] { err = mc.exec(\"SET NAMES \" + charset) }",
    "exploitation": "Attacker could inject SQL through charset parameter in connection string"
  },
  {
    "file": "starttls/mysql/connection.go",
    "line": 345,
    "category": "injection",
    "type": "SQL Injection",
    "severity": "high",
    "confidence": "medium",
    "cwe": "CWE-89",
    "description": "System variable name is directly concatenated into SELECT query without validation",
    "code_snippet": "if err := mc.writeCommandPacketStr(comQuery, \"SELECT @@\"+name); err != nil {",
    "remediation": "Validate system variable name against allowed list: validVars := map[string]bool{\"version\": true, \"max_connections\": true}; if validVars[name] { query := \"SELECT @@\" + name }",
    "exploitation": "If system variable name comes from untrusted input, attacker could inject SQL to extract sensitive information"
  },
  {
    "file": "starttls/mysql/connection.go",
    "line": 141,
    "category": "validation",
    "type": "Input Validation",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "Parameter interpolation only checks count of placeholders but not their validity or position",
    "code_snippet": "if strings.Count(query, \"?\") != len(args) {\n\treturn \"\", driver.ErrSkip\n}",
    "remediation": "Implement more robust parameter validation including context-aware parsing to ensure placeholders are in valid SQL positions",
    "exploitation": "Malformed queries with incorrect placeholder positioning could lead to unexpected SQL execution"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 361,
    "category": "crypto",
    "type": "Insecure TLS Configuration",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-295",
    "description": "TLS handshake performed without certificate validation or hostname verification",
    "code_snippet": "tlsConn := tls.Client(mc.netConn, mc.cfg.tls)\nif err := tlsConn.Handshake(); err != nil {\n\treturn err\n}",
    "remediation": "Ensure TLS config includes proper certificate validation: mc.cfg.tls.InsecureSkipVerify = false and set ServerName for hostname verification",
    "exploitation": "Man-in-the-middle attacks possible if TLS config allows insecure connections"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 460,
    "category": "exposure",
    "type": "Sensitive Data in Clear Text",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-319",
    "description": "Password sent in clear text over network when clear text authentication is used",
    "code_snippet": "// Add the clear password [null terminated string]\ncopy(data[4:], mc.cfg.Passwd)\ndata[4+pktLen-1] = 0x00",
    "remediation": "Ensure clear text authentication is only used over encrypted connections and implement stronger authentication methods",
    "exploitation": "Passwords can be intercepted in network traffic when clear text authentication is used without TLS"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 681,
    "category": "exposure",
    "type": "Error Information Disclosure",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "MySQL error messages with potentially sensitive information are passed through directly",
    "code_snippet": "return &MySQLError{\n\tNumber:  errno,\n\tMessage: string(data[pos:]),\n}",
    "remediation": "Filter or sanitize error messages before returning them to prevent information disclosure",
    "exploitation": "Internal database structure or sensitive information could be disclosed through detailed error messages"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 1122,
    "category": "validation",
    "type": "Buffer Over-read Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-125",
    "description": "Potential buffer over-read when accessing data array without proper bounds checking",
    "code_snippet": "dest[i] = int64(data[pos])",
    "remediation": "Add bounds checking: if pos >= len(data) { return ErrMalformPkt }",
    "exploitation": "Could lead to application crashes or memory disclosure if malformed packets are received"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 1128,
    "category": "validation",
    "type": "Buffer Over-read Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-125",
    "description": "Potential buffer over-read when reading 2-byte values without bounds checking",
    "code_snippet": "dest[i] = int64(binary.LittleEndian.Uint16(data[pos : pos+2]))",
    "remediation": "Add bounds checking: if pos+2 > len(data) { return ErrMalformPkt }",
    "exploitation": "Could lead to application crashes or memory disclosure if malformed packets are received"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 1135,
    "category": "validation",
    "type": "Buffer Over-read Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-125",
    "description": "Potential buffer over-read when reading 4-byte values without bounds checking",
    "code_snippet": "dest[i] = int64(binary.LittleEndian.Uint32(data[pos : pos+4]))",
    "remediation": "Add bounds checking: if pos+4 > len(data) { return ErrMalformPkt }",
    "exploitation": "Could lead to application crashes or memory disclosure if malformed packets are received"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 1142,
    "category": "validation",
    "type": "Buffer Over-read Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-125",
    "description": "Potential buffer over-read when reading 8-byte values without bounds checking",
    "code_snippet": "dest[i] = int64(binary.LittleEndian.Uint64(data[pos : pos+8]))",
    "remediation": "Add bounds checking: if pos+8 > len(data) { return ErrMalformPkt }",
    "exploitation": "Could lead to application crashes or memory disclosure if malformed packets are received"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 1153,
    "category": "validation",
    "type": "Buffer Over-read Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-125",
    "description": "Potential buffer over-read when reading float values without bounds checking",
    "code_snippet": "dest[i] = float32(math.Float32frombits(binary.LittleEndian.Uint32(data[pos : pos+4])))",
    "remediation": "Add bounds checking: if pos+4 > len(data) { return ErrMalformPkt }",
    "exploitation": "Could lead to application crashes or memory disclosure if malformed packets are received"
  },
  {
    "file": "starttls/mysql/packets.go",
    "line": 1157,
    "category": "validation",
    "type": "Buffer Over-read Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-125",
    "description": "Potential buffer over-read when reading double values without bounds checking",
    "code_snippet": "dest[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[pos : pos+8]))",
    "remediation": "Add bounds checking: if pos+8 > len(data) { return ErrMalformPkt }",
    "exploitation": "Could lead to application crashes or memory disclosure if malformed packets are received"
  },
  {
    "file": "starttls/mysql/driver.go",
    "line": 265,
    "category": "auth",
    "type": "Cleartext Password Authentication",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-287",
    "description": "The driver allows cleartext password authentication when AllowCleartextPasswords is enabled, transmitting passwords in plaintext over the network connection",
    "code_snippet": "} else if mc.cfg.AllowCleartextPasswords && err == ErrCleartextPassword {\n\t\t// Retry with clear text password for\n\t\t// http://dev.mysql.com/doc/refman/5.7/en/cleartext-authentication-plugin.html\n\t\t// http://dev.mysql.com/doc/refman/5.7/en/pam-authentication-plugin.html\n\t\tif err = mc.writeClearAuthPacket(); err != nil {\n\t\t\treturn err\n\t\t}",
    "remediation": "Disable cleartext password authentication and require encrypted authentication methods. Ensure TLS is always used when cleartext auth is absolutely necessary: if mc.cfg.AllowCleartextPasswords && mc.cfg.tls == nil { return errors.New(\"cleartext passwords require TLS\") }",
    "exploitation": "An attacker monitoring network traffic could intercept cleartext passwords during MySQL authentication, leading to credential compromise"
  },
  {
    "file": "starttls/mysql/dsn.go",
    "line": 533,
    "category": "crypto",
    "type": "Insecure TLS Configuration",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-295",
    "description": "TLS certificate verification is disabled when 'skip-verify' option is used, making connections vulnerable to man-in-the-middle attacks",
    "code_snippet": "cfg.tls = &tls.Config{InsecureSkipVerify: true}",
    "remediation": "Remove the skip-verify option or add strong warnings about its security implications. Consider requiring explicit confirmation for insecure configurations.",
    "exploitation": "Attacker can intercept TLS connections and perform man-in-the-middle attacks to steal credentials or modify data"
  },
  {
    "file": "starttls/mysql/dsn.go",
    "line": 420,
    "category": "exposure",
    "type": "Sensitive Data in Connection String",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-532",
    "description": "Password is included in DSN string formatting which could be logged or exposed in error messages",
    "code_snippet": "if len(cfg.Passwd) > 0 {\n\t\t\tbuf.WriteByte(':')\n\t\t\tbuf.WriteString(cfg.Passwd)\n\t\t}",
    "remediation": "Implement a String() method that masks passwords in output, or provide a separate method for generating connection strings without sensitive data for logging purposes.",
    "exploitation": "Passwords could be exposed in application logs, error messages, or debugging output"
  },
  {
    "file": "starttls/mysql/dsn.go",
    "line": 399,
    "category": "config",
    "type": "Insecure Default Configuration",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-1188",
    "description": "AllowAllFiles option enables LOAD DATA LOCAL INFILE for all files, which can lead to arbitrary file disclosure",
    "code_snippet": "if cfg.AllowAllFiles {\n\t\thasParam = true\n\t\tbuf.WriteString(\"?allowAllFiles=true\")\n\t}",
    "remediation": "Add documentation warnings about the security implications of AllowAllFiles. Consider requiring explicit file path whitelisting instead of allowing all files.",
    "exploitation": "Attacker could use LOAD DATA LOCAL INFILE to read arbitrary files from the client filesystem"
  },
  {
    "file": "starttls/mysql/dsn.go",
    "line": 407,
    "category": "config",
    "type": "Cleartext Password Authentication",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-319",
    "description": "AllowCleartextPasswords option enables transmission of passwords in cleartext",
    "code_snippet": "if cfg.AllowCleartextPasswords {\n\t\tif hasParam {\n\t\t\tbuf.WriteString(\"&allowCleartextPasswords=true\")\n\t\t}",
    "remediation": "Ensure this option is only used over encrypted connections (TLS). Add validation to prevent cleartext passwords over unencrypted connections.",
    "exploitation": "Passwords transmitted in cleartext can be intercepted by network attackers"
  },
  {
    "file": "starttls/mysql/dsn.go",
    "line": 427,
    "category": "config",
    "type": "Legacy Password Authentication",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "AllowOldPasswords enables pre-MySQL 4.1 authentication which uses weaker password hashing",
    "code_snippet": "if cfg.AllowOldPasswords {\n\t\tif hasParam {\n\t\t\tbuf.WriteString(\"&allowOldPasswords=true\")\n\t\t}",
    "remediation": "Discourage use of old password authentication. Add deprecation warnings and recommend upgrading to newer authentication methods.",
    "exploitation": "Weak password hashing makes credentials more vulnerable to brute force attacks"
  },
  {
    "file": "starttls/mysql/errors.go",
    "line": 179,
    "category": "exposure",
    "type": "Information Leakage",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Error message formatting may expose sensitive information through string interpolation of arbitrary values",
    "code_snippet": "warning.Message = fmt.Sprintf(\"%s\", values[0])",
    "remediation": "Use specific type assertions or sanitize error messages before logging. Consider: if raw, ok := values[2].([]byte); ok { warning.Message = string(raw) } else { warning.Message = \"invalid message format\" }",
    "exploitation": "If values[0] contains sensitive data, it could be exposed in error messages or logs"
  },
  {
    "file": "starttls/mysql/errors.go",
    "line": 25,
    "category": "exposure",
    "type": "Sensitive Data in Error Messages",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Clear text password error message may expose authentication method details to attackers",
    "code_snippet": "ErrCleartextPassword = errors.New(\"this user requires clear text authentication. If you still want to use it, please add 'allowCleartextPasswords=1' to your DSN\")",
    "remediation": "Reduce information disclosure in error messages: errors.New(\"authentication method not supported\")",
    "exploitation": "Reveals specific authentication requirements and configuration parameters that could aid reconnaissance"
  },
  {
    "file": "starttls/mysql/errors.go",
    "line": 27,
    "category": "exposure",
    "type": "Sensitive Data in Error Messages",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Old password error message exposes authentication method and provides configuration guidance to attackers",
    "code_snippet": "ErrOldPassword = errors.New(\"this user requires old password authentication. If you still want to use it, please add 'allowOldPasswords=1' to your DSN. See also https://github.com/go-sql-driver/mysql/wiki/old_passwords\")",
    "remediation": "Use generic error message: errors.New(\"authentication failed\")",
    "exploitation": "Reveals weak authentication methods are available and provides documentation links for exploitation"
  },
  {
    "file": "starttls/mysql/errors.go",
    "line": 42,
    "category": "config",
    "type": "Debug Information Disclosure",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-532",
    "description": "Error logger includes file path and line numbers which could leak internal application structure",
    "code_snippet": "var errLog = Logger(log.New(os.Stderr, \"[mysql] \", log.Ldate|log.Ltime|log.Lshortfile))",
    "remediation": "For production builds, remove log.Lshortfile flag: log.New(os.Stderr, \"[mysql] \", log.Ldate|log.Ltime)",
    "exploitation": "File paths in logs could reveal application structure and aid in path traversal attacks"
  },
  {
    "file": "starttls/ciphersuites.go",
    "line": 35,
    "category": "crypto",
    "type": "Weak Encryption Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "3DES (Triple DES) cipher suites are included in the preference order. 3DES is considered weak due to its 64-bit block size making it vulnerable to birthday attacks",
    "code_snippet": "tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA,\n\ttls.TLS_RSA_WITH_3DES_EDE_CBC_SHA,",
    "remediation": "Remove 3DES cipher suites from the preference order and avoid using them. Use AES-128 or AES-256 instead: remove lines containing TLS_*_WITH_3DES_EDE_CBC_SHA",
    "exploitation": "Attackers can exploit 3DES vulnerabilities to decrypt TLS traffic, especially with high-volume connections due to Sweet32 attack (CVE-2016-2183)"
  },
  {
    "file": "starttls/ciphersuites.go",
    "line": 41,
    "category": "crypto",
    "type": "Weak Encryption Algorithm",
    "severity": "critical",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "RC4 cipher suites are included in the preference order. RC4 is cryptographically broken with multiple known attacks and biases",
    "code_snippet": "tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,\n\ttls.TLS_RSA_WITH_RC4_128_SHA,",
    "remediation": "Remove all RC4 cipher suites from the preference order: remove lines containing TLS_*_WITH_RC4_128_SHA. RC4 should never be used for security-sensitive applications",
    "exploitation": "RC4 has known statistical biases and attacks that allow plaintext recovery. Attackers can decrypt TLS traffic encrypted with RC4"
  },
  {
    "file": "starttls/ciphersuites.go",
    "line": 47,
    "category": "crypto",
    "type": "Insecure Cipher Configuration",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "The code explicitly includes insecure cipher suites from tls.InsecureCipherSuites() in the supported cipher list",
    "code_snippet": "insecureSuites := tls.InsecureCipherSuites()",
    "remediation": "Consider whether insecure cipher suites should be supported. For production systems, only use secure cipher suites: suites := tls.CipherSuites() without including InsecureCipherSuites()",
    "exploitation": "Including insecure cipher suites allows clients to negotiate weak encryption that may be vulnerable to cryptographic attacks"
  },
  {
    "file": "starttls/ciphersuites.go",
    "line": 28,
    "category": "crypto",
    "type": "Weak Cipher Mode",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-327",
    "description": "CBC mode cipher suites are prioritized over some AEAD modes. CBC mode is vulnerable to padding oracle attacks",
    "code_snippet": "tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA, tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,\n\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA, tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,",
    "remediation": "Prioritize AEAD cipher suites (GCM, ChaCha20-Poly1305) over CBC modes. Move CBC cipher suites to the end of the preference list or remove them entirely",
    "exploitation": "CBC mode with HMAC is susceptible to timing attacks and padding oracle vulnerabilities that can lead to plaintext recovery"
  },
  {
    "file": "starttls/imap.go",
    "line": 35,
    "category": "validation",
    "type": "Type Assertion Without Check",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-704",
    "description": "Unsafe type assertion from net.Conn to *net.TCPConn without checking if the assertion succeeds",
    "code_snippet": "conn := c.(*net.TCPConn)",
    "remediation": "Use safe type assertion: conn, ok := c.(*net.TCPConn); if !ok { return nil, fmt.Errorf(\"expected TCP connection\") }",
    "exploitation": "If the dialer returns a non-TCP connection, this will cause a runtime panic, leading to denial of service"
  },
  {
    "file": "starttls/imap.go",
    "line": 48,
    "category": "injection",
    "type": "Protocol Injection",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-74",
    "description": "Fixed IMAP command sent without input validation, though no user input is involved in this case",
    "code_snippet": "fmt.Fprintf(conn, \"1 STARTTLS\\r\\n\")",
    "remediation": "Current implementation is acceptable as the command is hardcoded, but consider using a constant: const startTLSCmd = \"1 STARTTLS\\r\\n\"",
    "exploitation": "Low risk as the command is hardcoded, but protocol injection patterns should be reviewed"
  },
  {
    "file": "starttls/imap.go",
    "line": 65,
    "category": "validation",
    "type": "Buffer Overflow Risk",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-120",
    "description": "ReadString() can potentially read unlimited data until newline, which could cause memory exhaustion",
    "code_snippet": "response, err := reader.ReadString('\\n')",
    "remediation": "Use bufio.NewReaderSize() with a reasonable limit or implement a timeout: reader := bufio.NewReaderSize(conn, 4096)",
    "exploitation": "Malicious IMAP server could send very long lines without newlines, causing memory exhaustion"
  },
  {
    "file": "starttls/imap.go",
    "line": 69,
    "category": "validation",
    "type": "Array Index Out of Bounds",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-129",
    "description": "Array slice operation assumes response is at least 4 characters long without validation",
    "code_snippet": "return response[2:4], nil",
    "remediation": "Add length validation: if len(response) < 4 { return \"\", fmt.Errorf(\"invalid IMAP response format\") }; return response[2:4], nil",
    "exploitation": "Short or malformed IMAP responses will cause a runtime panic, leading to denial of service"
  },
  {
    "file": "starttls/imap.go",
    "line": 30,
    "category": "config",
    "type": "Missing Timeout Configuration",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-1088",
    "description": "Network operations lack timeout configuration, making the application vulnerable to hanging connections",
    "code_snippet": "c, err := dialer.Dial(\"tcp\", address)",
    "remediation": "Set connection timeouts: conn.SetDeadline(time.Now().Add(30*time.Second)) after establishing connection",
    "exploitation": "Slow or unresponsive IMAP servers can cause the application to hang indefinitely"
  },
  {
    "file": "starttls/ftp.go",
    "line": 41,
    "category": "validation",
    "type": "Type Assertion Without Check",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-20",
    "description": "Unsafe type assertion on dialer.Dial() result without checking if the connection is actually a TCPConn",
    "code_snippet": "conn := c.(*net.TCPConn)",
    "remediation": "Check type assertion result: conn, ok := c.(*net.TCPConn); if !ok { return nil, fmt.Errorf(\"expected TCP connection\") }",
    "exploitation": "If dialer returns a non-TCP connection, this will cause a runtime panic that could crash the application"
  },
  {
    "file": "starttls/ftp.go",
    "line": 54,
    "category": "injection",
    "type": "Command Injection",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-74",
    "description": "Fixed FTP command sent without input validation, but using fmt.Fprintf could potentially be misused if modified",
    "code_snippet": "fmt.Fprintf(conn, \"AUTH TLS\\r\\n\")",
    "remediation": "Use conn.Write() with byte literals: conn.Write([]byte(\"AUTH TLS\\r\\n\"))",
    "exploitation": "Currently safe as command is hardcoded, but vulnerable to modification that introduces user input"
  },
  {
    "file": "starttls/ftp.go",
    "line": 70,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Error message exposes raw FTP server response which might contain sensitive information",
    "code_snippet": "return 0, fmt.Errorf(\"Error parsing ftp protocol: Status code too short: '%s'\", response)",
    "remediation": "Sanitize error message: return 0, fmt.Errorf(\"Error parsing ftp protocol: Status code too short\")",
    "exploitation": "FTP server response might contain internal server information or version details that aid reconnaissance"
  },
  {
    "file": "starttls/ftp.go",
    "line": 67,
    "category": "validation",
    "type": "Insufficient Input Validation",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "FTP response parsing lacks comprehensive validation - only checks length but not format",
    "code_snippet": "if len(response) <= 3 {\n        return 0, fmt.Errorf(\"Error parsing ftp protocol: Status code too short: '%s'\", response)\n    }\n    return strconv.Atoi(response[:3])",
    "remediation": "Add format validation: if !regexp.MustCompile(`^\\d{3}\\s`).MatchString(response) { return 0, fmt.Errorf(\"Invalid FTP response format\") }",
    "exploitation": "Malformed FTP responses could cause strconv.Atoi to fail or return unexpected values, potentially causing protocol confusion"
  },
  {
    "file": "lib/ocsp.go",
    "line": 106,
    "category": "validation",
    "type": "Server-Side Request Forgery (SSRF)",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-918",
    "description": "OCSP server URLs from certificates are used directly in HTTP requests without validation, allowing potential SSRF attacks",
    "code_snippet": "for _, server := range cert.OCSPServer {\n    // ...\n    resp, err := ocspHttpClient.Do(req)",
    "remediation": "Validate OCSP server URLs before making requests. Implement URL allowlists and block internal/private IP ranges:\n\nfunc isValidOCSPURL(urlStr string) error {\n    u, err := url.Parse(urlStr)\n    if err != nil {\n        return err\n    }\n    \n    if u.Scheme != \"http\" && u.Scheme != \"https\" {\n        return errors.New(\"invalid scheme\")\n    }\n    \n    ip := net.ParseIP(u.Hostname())\n    if ip != nil && (ip.IsLoopback() || ip.IsPrivate()) {\n        return errors.New(\"private IP not allowed\")\n    }\n    \n    return nil\n}",
    "exploitation": "Attacker could craft a malicious certificate with OCSP server URLs pointing to internal services, allowing network reconnaissance or attacks on internal infrastructure"
  },
  {
    "file": "lib/ocsp.go",
    "line": 155,
    "category": "validation",
    "type": "Improper Resource Management",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-770",
    "description": "No limit on response body size when reading OCSP responses, potentially allowing memory exhaustion attacks",
    "code_snippet": "return io.ReadAll(resp.Body)",
    "remediation": "Limit the response body size to prevent memory exhaustion:\n\nconst maxOCSPResponseSize = 64 * 1024 // 64KB\n\nbody, err := io.ReadAll(io.LimitReader(resp.Body, maxOCSPResponseSize))",
    "exploitation": "Attacker could serve large OCSP responses to exhaust server memory"
  },
  {
    "file": "lib/ocsp.go",
    "line": 48,
    "category": "config",
    "type": "Insufficient Timeout Configuration",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-1088",
    "description": "HTTP client timeout of 5 seconds may be insufficient for legitimate OCSP servers, but no maximum number of concurrent requests is enforced",
    "code_snippet": "ocspHttpClient = &http.Client{\n    Timeout: 5 * time.Second,\n}",
    "remediation": "Consider implementing rate limiting and connection pooling:\n\nocspHttpClient = &http.Client{\n    Timeout: 10 * time.Second,\n    Transport: &http.Transport{\n        MaxIdleConns:       10,\n        IdleConnTimeout:    30 * time.Second,\n        DisableCompression: true,\n    },\n}",
    "exploitation": "Could be used in conjunction with SSRF to overwhelm internal services with requests"
  },
  {
    "file": "lib/ocsp.go",
    "line": 175,
    "category": "validation",
    "type": "HTTP Request Construction Flaw",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-20",
    "description": "POST request body is incorrectly written using req.Write() instead of setting req.Body, which may cause malformed requests",
    "code_snippet": "req.Header.Add(\"Content-Type\", \"application/ocsp-request\")\nreq.Header.Add(\"Accept\", \"application/ocsp-response\")\nerr = req.Write(bytes.NewBuffer(encoded))",
    "remediation": "Properly construct POST request with body:\n\nreq, err := http.NewRequest(\"POST\", server, bytes.NewBuffer(encoded))\nif err != nil {\n    return nil, err\n}\nreq.Header.Add(\"Content-Type\", \"application/ocsp-request\")\nreq.Header.Add(\"Accept\", \"application/ocsp-response\")",
    "exploitation": "May cause OCSP requests to fail or behave unexpectedly, potentially bypassing certificate validation"
  },
  {
    "file": "lib/ocsp.go",
    "line": 189,
    "category": "validation",
    "type": "URL Injection",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-20",
    "description": "Base64-encoded OCSP request data is directly concatenated into URL path without proper URL encoding, potentially allowing URL manipulation",
    "code_snippet": "url := fmt.Sprintf(\"%s/%s\", server, base64.StdEncoding.EncodeToString(encoded))",
    "remediation": "Use proper URL path escaping:\n\nimport \"net/url\"\n\nencoded64 := base64.StdEncoding.EncodeToString(encoded)\nurl := fmt.Sprintf(\"%s/%s\", server, url.PathEscape(encoded64))",
    "exploitation": "Attacker could potentially manipulate the URL structure if the base64 data contains characters that have special meaning in URLs"
  },
  {
    "file": "lib/encoder.go",
    "line": 213,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA1 signature schemes are cryptographically weak and vulnerable to collision attacks",
    "code_snippet": "tls.PKCS1WithSHA1: \"RSA-PKCS1 with SHA1\",\n0x203: \"ECDSA with SHA1\",\nx509.SHA1WithRSA: \"SHA1-RSA\",\nx509.ECDSAWithSHA1: \"ECDSA-SHA1\",",
    "remediation": "Remove support for SHA1-based signature schemes and use SHA256 or stronger algorithms. Update code to reject certificates using weak algorithms.",
    "exploitation": "Attackers could potentially forge certificates or signatures by exploiting SHA1 collision vulnerabilities"
  },
  {
    "file": "lib/encoder.go",
    "line": 238,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "MD5 signature scheme is cryptographically broken and should not be supported",
    "code_snippet": "0x101: \"RSA-PKCS1 with MD5\",\n0x102: \"DSA with MD5\",\nx509.MD2WithRSA: \"MD2-RSA\",\nx509.MD5WithRSA: \"MD5-RSA\",",
    "remediation": "Remove support for MD5 and MD2 signature schemes entirely. These algorithms are cryptographically broken and should not be recognized.",
    "exploitation": "MD5 hash collisions can be generated, allowing attackers to create forged certificates with the same hash"
  },
  {
    "file": "lib/encoder.go",
    "line": 560,
    "category": "exposure",
    "type": "Error Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Detailed error messages from certificate parsing are included in output, potentially exposing internal system information",
    "code_snippet": "lints = append(lints, fmt.Sprintf(\"Failed to parse certificate: %v\", err))",
    "remediation": "Sanitize error messages before including in output: lints = append(lints, \"Failed to parse certificate: invalid format\")",
    "exploitation": "Detailed error messages could reveal internal system paths, library versions, or implementation details to attackers"
  },
  {
    "file": "lib/display.go",
    "line": 256,
    "category": "injection",
    "type": "Template Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-94",
    "description": "Template execution uses user-controlled data from certificate fields which could contain malicious template syntax",
    "code_snippet": "err = t.Execute(w, cert)",
    "remediation": "Sanitize certificate field values before template execution or use text/template with AllowMissingKeys set to false and validate all input data",
    "exploitation": "Malicious certificates with crafted field values could execute arbitrary template code during rendering"
  },
  {
    "file": "lib/display.go",
    "line": 242,
    "category": "injection",
    "type": "Template Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-94",
    "description": "Template parsing with user-controlled layout strings could allow template injection",
    "code_snippet": "t, err = t.Parse(verboseLayout)",
    "remediation": "Use pre-compiled templates or validate template strings against a whitelist of allowed patterns",
    "exploitation": "If layout templates are ever sourced from user input or configuration files, attackers could inject malicious template code"
  },
  {
    "file": "lib/display.go",
    "line": 148,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Panic with error details could expose internal information in stack traces",
    "code_snippet": "if err != nil {\n\t\tpanic(err)\n\t}",
    "remediation": "Handle errors gracefully and log them without exposing details to end users: log.Error(err); return []byte(\"encoding error\")",
    "exploitation": "Stack traces from panics could reveal internal paths, function names, and system information"
  },
  {
    "file": "lib/display.go",
    "line": 249,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Panic in template parsing could expose internal template structure",
    "code_snippet": "if err != nil {\n\t\t// Should never happen\n\t\tpanic(err)\n\t}",
    "remediation": "Handle template parsing errors gracefully: if err != nil { log.Error(err); return []byte(\"template error\") }",
    "exploitation": "Template parsing errors could reveal internal template implementation details"
  },
  {
    "file": "lib/display.go",
    "line": 257,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Panic in template execution could expose internal data structures",
    "code_snippet": "if err != nil {\n\t\t// Should never happen\n\t\tpanic(err)\n\t}",
    "remediation": "Handle template execution errors gracefully instead of panicking",
    "exploitation": "Template execution errors could reveal certificate data structure and processing details"
  },
  {
    "file": "lib/display.go",
    "line": 227,
    "category": "validation",
    "type": "Insufficient Input Validation",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "terminalWidth parameter not validated, could cause buffer issues or unexpected behavior",
    "code_snippet": "c.Width = terminalWidth - 8",
    "remediation": "Validate terminalWidth: if terminalWidth < 10 { terminalWidth = 80 }; c.Width = terminalWidth - 8",
    "exploitation": "Negative or extremely large terminal width values could cause formatting issues or unexpected behavior"
  },
  {
    "file": "lib/ct.go",
    "line": 79,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "MD5 hash algorithm is used in signature verification. MD5 is cryptographically broken and vulnerable to collision attacks.",
    "code_snippet": "case cttls.MD5:\n\t\t\tx509Alg = x509.MD5WithRSA",
    "remediation": "Remove MD5 support entirely or explicitly reject MD5-based signatures:\nif alg.Hash == cttls.MD5 {\n\treturn simpleSigAlg(x509.UnknownSignatureAlgorithm) // Reject MD5\n}",
    "exploitation": "Attacker could create malicious certificates with MD5 signatures that appear valid due to hash collisions"
  },
  {
    "file": "lib/ct.go",
    "line": 81,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA1 hash algorithm is used in signature verification. SHA1 has known collision vulnerabilities and should be deprecated.",
    "code_snippet": "case cttls.SHA1:\n\t\t\tx509Alg = x509.SHA1WithRSA",
    "remediation": "Consider deprecating SHA1 support and log warnings when encountered:\ncase cttls.SHA1:\n\t// Log warning about deprecated algorithm\n\tlog.Warn(\"SHA1 signature algorithm is deprecated and should not be used\")\n\tx509Alg = x509.SHA1WithRSA",
    "exploitation": "While harder to exploit than MD5, SHA1 collisions could potentially be used to create fraudulent certificates"
  },
  {
    "file": "lib/ct.go",
    "line": 91,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA1 with DSA signature algorithm is supported. SHA1 is cryptographically weak.",
    "code_snippet": "case cttls.SHA1:\n\t\t\tx509Alg = x509.DSAWithSHA1",
    "remediation": "Deprecate SHA1 with DSA:\ncase cttls.SHA1:\n\t// SHA1 is deprecated\n\tlog.Warn(\"DSA with SHA1 is deprecated\")\n\tx509Alg = x509.DSAWithSHA1",
    "exploitation": "SHA1 collision attacks could compromise DSA signature integrity"
  },
  {
    "file": "lib/ct.go",
    "line": 97,
    "category": "crypto",
    "type": "Weak Hash Algorithm",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "SHA1 with ECDSA signature algorithm is supported. SHA1 is cryptographically weak.",
    "code_snippet": "case cttls.SHA1:\n\t\t\tx509Alg = x509.ECDSAWithSHA1",
    "remediation": "Deprecate SHA1 with ECDSA:\ncase cttls.SHA1:\n\t// SHA1 is deprecated\n\tlog.Warn(\"ECDSA with SHA1 is deprecated\")\n\tx509Alg = x509.ECDSAWithSHA1",
    "exploitation": "SHA1 vulnerabilities could be exploited to forge ECDSA signatures"
  },
  {
    "file": "lib/ct.go",
    "line": 32,
    "category": "validation",
    "type": "Missing Error Handling",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-252",
    "description": "Certificate parsing errors are silently ignored, which could mask malformed or malicious certificate data.",
    "code_snippet": "if scts, err := ctutil.ParseSCTsFromCertificate(cert.Raw); err == nil {",
    "remediation": "Log parsing errors for debugging and security monitoring:\nif scts, err := ctutil.ParseSCTsFromCertificate(cert.Raw); err == nil {\n\t// existing code\n} else {\n\tlog.Debug(\"Failed to parse SCTs from certificate: %v\", err)\n\treturn nil\n}",
    "exploitation": "Parsing errors could indicate certificate tampering attempts that go unnoticed"
  },
  {
    "file": "lib/certs.go",
    "line": 42,
    "category": "crypto",
    "type": "Weak Hash Algorithms",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "The code explicitly lists weak signature algorithms (MD2, MD5, SHA1) but only stores them in an array without preventing their use",
    "code_snippet": "var badSignatureAlgorithms = [...]x509.SignatureAlgorithm{\n\tx509.MD2WithRSA,\n\tx509.MD5WithRSA,\n\tx509.SHA1WithRSA,\n\tx509.DSAWithSHA1,\n\tx509.ECDSAWithSHA1,\n}",
    "remediation": "Add validation to reject certificates using these weak algorithms:\n\nfunc validateCertificate(cert *x509.Certificate) error {\n\tfor _, badAlg := range badSignatureAlgorithms {\n\t\tif cert.SignatureAlgorithm == badAlg {\n\t\t\treturn fmt.Errorf(\"certificate uses weak signature algorithm: %s\", cert.SignatureAlgorithm)\n\t\t}\n\t}\n\treturn nil\n}",
    "exploitation": "Certificates with weak signature algorithms can be forged or have their signatures broken through cryptographic attacks"
  },
  {
    "file": "lib/certs.go",
    "line": 364,
    "category": "crypto",
    "type": "Deprecated Cryptographic Function",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Using deprecated pkcs12.ToPEM function which produces non-standard PEM blocks that may not be in proper PKCS#8 format",
    "code_snippet": "//nolint:staticcheck // See comment\nblocks, err := pkcs12.ToPEM(data, password)",
    "remediation": "Replace with newer PKCS#12 parsing functions that properly handle PKCS#8 format:\n\n// Use pkcs12.Decode instead\nprivateKey, cert, caCerts, err := pkcs12.Decode(data, password)\nif err != nil {\n\treturn nil, err\n}\n// Then properly encode to PKCS#8 format\npkcs8Bytes, err := x509.MarshalPKCS8PrivateKey(privateKey)",
    "exploitation": "Non-standard key formats may be rejected by other systems or cause interoperability issues"
  },
  {
    "file": "lib/certs.go",
    "line": 201,
    "category": "validation",
    "type": "Missing Input Validation",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-20",
    "description": "The password function is called with empty string as default, but there's no validation of the password strength or format",
    "code_snippet": "blocks, err := pkcs12ToPemBlocks(data, password(\"\"))",
    "remediation": "Add password validation and require non-empty passwords for encrypted keystores:\n\nfunc validatePassword(password string) error {\n\tif password == \"\" {\n\t\treturn fmt.Errorf(\"password cannot be empty for encrypted keystore\")\n\t}\n\treturn nil\n}\n\n// Then validate before use\npass := password(\"\")\nif err := validatePassword(pass); err != nil {\n\treturn err\n}",
    "exploitation": "Weak or empty passwords make encrypted keystores vulnerable to brute force attacks"
  },
  {
    "file": "lib/certs.go",
    "line": 299,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-209",
    "description": "Error messages may expose internal file paths and system information through the fileHeader functionality",
    "code_snippet": "if filename != \"\" && filename != os.Stdin.Name() {\n\theaders[fileHeader] = filename\n}",
    "remediation": "Sanitize file paths in headers to prevent information disclosure:\n\nfunc sanitizeFilename(filename string) string {\n\tif filename == \"\" || filename == os.Stdin.Name() {\n\t\treturn \"\"\n\t}\n\treturn filepath.Base(filename) // Only include base filename\n}\n\nheaders[fileHeader] = sanitizeFilename(filename)",
    "exploitation": "Internal file paths could reveal system structure and aid in further attacks"
  },
  {
    "file": "lib/certs.go",
    "line": 275,
    "category": "validation",
    "type": "Path Traversal Risk",
    "severity": "low",
    "confidence": "low",
    "cwe": "CWE-22",
    "description": "File extension checking uses user-controlled filename without sanitization",
    "code_snippet": "guess, ok := fileExtToFormat[strings.ToLower(filepath.Ext(filename))]",
    "remediation": "Sanitize the filename before processing:\n\ncleanFilename := filepath.Clean(filename)\nif strings.Contains(cleanFilename, \"..\") {\n\treturn \"\", fmt.Errorf(\"invalid filename\")\n}\nguess, ok := fileExtToFormat[strings.ToLower(filepath.Ext(cleanFilename))]",
    "exploitation": "If filenames come from user input, path traversal sequences could potentially cause issues in file type detection"
  },
  {
    "file": "lib/ctlogs.go",
    "line": 48,
    "category": "config",
    "type": "Insecure HTTP URLs",
    "severity": "medium",
    "confidence": "high",
    "cwe": "CWE-319",
    "description": "HTTP URLs found in CT log configuration that transmit data without encryption",
    "code_snippet": "\"z1XiiSNJfDQNUgbQU1Ouslg0tS8fjclSaAnyEu/dfKY=\": {operator: \"SHECA\", url: \"http://ctlog.sheca.com/\"},",
    "remediation": "Replace HTTP URLs with HTTPS equivalents to ensure encrypted communication: url: \"https://ctlog.sheca.com/\"",
    "exploitation": "Man-in-the-middle attacks could intercept or modify CT log requests, potentially compromising certificate transparency verification"
  },
  {
    "file": "lib/ctlogs.go",
    "line": 8,
    "category": "exposure",
    "type": "Information Disclosure",
    "severity": "low",
    "confidence": "medium",
    "cwe": "CWE-200",
    "description": "Exported global variable exposes internal CT log configuration",
    "code_snippet": "var knownLogs = map[string]*ctLog{",
    "remediation": "Consider making the variable unexported if it's only used internally: var knownLogs = map[string]*ctLog{",
    "exploitation": "External packages could access and potentially misuse the CT log configuration data"
  },
  {
    "file": "lib/tls.go",
    "line": 73,
    "category": "injection",
    "type": "Template Injection",
    "severity": "high",
    "confidence": "medium",
    "cwe": "CWE-94",
    "description": "User-controlled data is passed to template execution without proper sanitization, potentially allowing template injection attacks",
    "code_snippet": "err = t.Execute(w, tlsInfoContext)",
    "remediation": "Sanitize all user-controlled data before template execution or use safer templating approaches with auto-escaping. Consider validating certificate data structure before passing to template.",
    "exploitation": "If certificate data contains malicious template syntax, an attacker could potentially execute arbitrary code or access sensitive data through template functions"
  },
  {
    "file": "lib/tls.go",
    "line": 65,
    "category": "injection",
    "type": "Template Injection",
    "severity": "medium",
    "confidence": "medium",
    "cwe": "CWE-94",
    "description": "Template parsing uses external template functions (sprig) that may introduce additional attack surface",
    "code_snippet": "funcMap := sprig.TxtFuncMap()\n\tt := template.New(\"TLS template\").Funcs(funcMap)",
    "remediation": "Limit template functions to only those required. Use a whitelist of safe functions instead of importing all sprig functions. Consider using html/template for auto-escaping.",
    "exploitation": "Sprig template functions provide extensive capabilities that could be abused if malicious template content is processed"
  },
  {
    "file": "lib/tls.go",
    "line": 77,
    "category": "exposure",
    "type": "Error Information Disclosure",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Template execution errors trigger panic, potentially exposing sensitive error information",
    "code_snippet": "if err != nil {\n\t\t// Should never happen\n\t\tpanic(err)\n\t}",
    "remediation": "Handle template execution errors gracefully instead of panicking: return err or log error and return safe default message",
    "exploitation": "Panic conditions could expose internal application details or stack traces to attackers"
  },
  {
    "file": "lib/tls.go",
    "line": 83,
    "category": "exposure",
    "type": "Error Information Disclosure",
    "severity": "low",
    "confidence": "high",
    "cwe": "CWE-209",
    "description": "Buffer flush errors trigger panic, potentially exposing sensitive error information",
    "code_snippet": "if err != nil {\n\t\t// Should never happen\n\t\tpanic(err)\n\t}",
    "remediation": "Handle flush errors gracefully instead of panicking: return err or log error safely",
    "exploitation": "Panic conditions could expose internal application details or stack traces to attackers"
  },
  {
    "file": "lib/tls.go",
    "line": 157,
    "category": "crypto",
    "type": "Weak Cipher Suites",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Code explicitly supports weak and insecure cipher suites including RC4 and 3DES",
    "code_snippet": "tls.TLS_RSA_WITH_RC4_128_SHA: {\"\", \"TLS_RSA_WITH_RC4_128_SHA\", insecure},\n\ttls.TLS_RSA_WITH_3DES_EDE_CBC_SHA: {\"\", \"TLS_RSA_WITH_3DES_EDE_CBC_SHA\", insecure},",
    "remediation": "Remove support for insecure cipher suites. Only allow secure ciphers: return error or refuse connection for weak ciphers instead of just marking them as 'insecure'",
    "exploitation": "Applications using this library could negotiate weak cipher suites, making TLS connections vulnerable to cryptographic attacks"
  },
  {
    "file": "lib/tls.go",
    "line": 145,
    "category": "crypto",
    "type": "Weak TLS Versions",
    "severity": "high",
    "confidence": "high",
    "cwe": "CWE-327",
    "description": "Code explicitly supports deprecated TLS versions 1.0 and 1.1 which have known security vulnerabilities",
    "code_snippet": "tls.VersionTLS10: {\"TLS 1.0\", \"tls_1_0\", insecure},\n\ttls.VersionTLS11: {\"TLS 1.1\", \"tls_1_1\", ok},",
    "remediation": "Remove support for TLS versions below 1.2. Return error for connections using TLS 1.0/1.1 instead of just marking as 'insecure'",
    "exploitation": "Applications using this library could accept connections with vulnerable TLS versions, exposing traffic to downgrade and cryptographic attacks"
  }
]
